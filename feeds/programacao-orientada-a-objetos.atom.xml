<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>eXcript</title><link>http://excript.com/</link><description></description><lastBuildDate>Thu, 16 Jun 2016 01:00:00 -0300</lastBuildDate><item><title>Implementando Comportamentos de Classe com PHP</title><link>http://excript.com/php/implementando-funcionalidades-classe-php.html</link><description>
    &lt;div class="admonitionblock note data-line" style="margin-top: 1.50em"&gt;
        &lt;table style="margin: 0"&gt;
            &lt;tbody&gt;
                &lt;tr&gt;
                    &lt;td class="content" style="border-left: 0"&gt;
                        &lt;div class="paragraph data-line"&gt;
                            &lt;p&gt; Nesta aula aprenderemos a implementar funcionalidades em nossas classes em PHP, bem como a forma em que devemos estruturas nossas classes.&lt;/p&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/tbody&gt;
        &lt;/table&gt;
    &lt;/div&gt;
&lt;div class="section" id="implementando-os-comportamentos"&gt;
&lt;h2&gt;IMPLEMENTANDO OS COMPORTAMENTOS&lt;/h2&gt;
&lt;p&gt;Todo objeto possui propriedades e todo objeto pode desempenhar alguma tarefa. É comum que um objeto desempenhe ações relacionadas as informações definidas em sua estrutura. Ou seja, as funções, na maioria das vezes, manipularão os atributos.&lt;/p&gt;
&lt;p&gt;Podemos reescrever o conceito acima pelo uso de estado e comportamento.&lt;/p&gt;
&lt;p&gt;Todo objeto possui estados e, todo objeto possui comportamentos. É comum que um objeto desempenhe comportamentos relacionadas as informações definidas em sua estrutura. Ou seja, os comportamentos, na maioria das vezes, manipularão os estados.&lt;/p&gt;
&lt;p&gt;Reescrevemos os conceitos somente por uma questão conceitual.&lt;/p&gt;
&lt;p&gt;As tarefas que um objeto executa são chamado de comportamentos, porém, a implementação não passa de uma função, cuja sintaxe é igual a sintaxe de qualquer função.&lt;/p&gt;
&lt;p&gt;Por fim, temos que as variáveis de uma instância guardarão as informações, enquanto que as funções manipulação as variáveis.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="estruturas-de-dados"&gt;
&lt;h2&gt;ESTRUTURAS DE DADOS&lt;/h2&gt;
&lt;p&gt;O grande avanço das na estruturação das linguagens de programação foi a implementação da capacidade de agrupar funcionalidade e atributos numa mesta estrutura. Assim, conseguimos definir estruturas que possuem um conjunto de propriedades e fazer com que estas só sejam manipuladas através de funções pré-definidas pela classe. A esse conceito chamamos de interface pública, ou seja, o conjunto de funções para a interação com a classe constitui uma interface para o acesso externo.&lt;/p&gt;
&lt;p&gt;A ideia de ter atributos e funcionalidades numa mesma estrutura é responsável pela evolução da informática e a implementação desse conceito é, em suma, o que hoje chamamos de Orientação a Objetos.&lt;/p&gt;
&lt;p&gt;O nosso objetivo a partir de agora é, a criação de programas modulares e, a definição, em cada classe, dos atributos pertinentes a entidade.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="uma-primeira-nocao-de-encapsulamento"&gt;
&lt;h2&gt;UMA PRIMEIRA NOÇÃO DE ENCAPSULAMENTO&lt;/h2&gt;
&lt;p&gt;Mesmo que não tenhamos estudado o conceito de encapsulamento, podemos observar que, os objetos funcionam como uma cápsula, onde as propriedades são o conteúdo da capsula, enquanto as funções, irão assumir uma de duas opções. a) de uso intero; b) uso externo. As funções internas, deverão ter seus nomes restritos ao escopo da classe, enquanto que as funções de uso externo, deverão ter suas funções decladas como sendo pública e estas, formarão, a interface de comunicação entre o mundo exterior e o conteúdo interno da classe.&lt;/p&gt;
&lt;p&gt;Por fim, só o conceito de manter os dados e as funções num mesmo lugar já é, por definição, uma maneira de encapsulamento, até porque, para acessarmos uma propriedade ou um funcionalidade somos obrigados a especificar a capsula que desejamos manipular.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;class Teste {&lt;/span&gt;
&lt;span class="x"&gt;    function imprimeTeste(){&lt;/span&gt;
&lt;span class="x"&gt;        echo &amp;quot;teste&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;

&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="exemplo-feito-em-aula"&gt;
&lt;h2&gt;EXEMPLO FEITO EM AULA&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;#IMPLEMENTANDO FUNÇÕES I&lt;/span&gt;

&lt;span class="x"&gt;class Teste{&lt;/span&gt;

&lt;span class="x"&gt;    public function imprimeTeste(){&lt;/span&gt;
&lt;span class="x"&gt;        echo &amp;quot;Função imprimeTeste() da classe de nome Teste&amp;quot;;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;

&lt;span class="x"&gt;}&lt;/span&gt;

&lt;span class="x"&gt;$t1 = new Teste();&lt;/span&gt;
&lt;span class="x"&gt;$t1 -&amp;gt; imprimeTeste();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Cláudio Rogério Carvalho Filho</dc:creator><pubDate>Thu, 16 Jun 2016 01:00:00 -0300</pubDate><guid isPermaLink="false">tag:excript.com,2016-06-16:php/implementando-funcionalidades-classe-php.html</guid><category>curso</category><category>php</category><category>programação orientada a objetos</category><category>poo</category><category>classe</category><category>objeto</category><category>instância</category><category>interface</category><category>interface pública</category><category>blog</category></item><item><title>Pseudo-variável $this em PHP</title><link>http://excript.com/php/pseudo-variavel-this-php.html</link><description>
    &lt;div class="admonitionblock note data-line" style="margin-top: 1.50em"&gt;
        &lt;table style="margin: 0"&gt;
            &lt;tbody&gt;
                &lt;tr&gt;
                    &lt;td class="content" style="border-left: 0"&gt;
                        &lt;div class="paragraph data-line"&gt;
                            &lt;p&gt; Nesta aula estudaremos a pseudo-variável $this. Entenderemos a sua definição e quando devemos utiliza-la na construção de classes PHP.&lt;/p&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/tbody&gt;
        &lt;/table&gt;
    &lt;/div&gt;
&lt;div class="section" id="pseudo-variavel"&gt;
&lt;h2&gt;PSEUDO-VARIÁVEL&lt;/h2&gt;
&lt;p&gt;Pseudo-variável é um nome que será utilizado como se fosse uma variável, porém, que não é verdadeiramente uma variável. Por isso o prefixo &lt;strong&gt;pseudo&lt;/strong&gt;, que significa, falso.&lt;/p&gt;
&lt;p&gt;Cada classe PHP, possui uma pseudo-variável de nome &lt;code&gt;$this&lt;/code&gt;. Chamamos a mesma de pseudo-variável até porque, a mesma funciona de maneira diferente das demais variáveis e quem a manipula, é a máquina virtual do PHP.&lt;/p&gt;
&lt;p&gt;O que temos que entender, é que &lt;code&gt;$this&lt;/code&gt; aponta para um objeto na memória, no caso, o objeto em execução, ou melhor, o objeto onde a mesma está contida, ou então, vamos dizer que a mesma aponta para si própria. Cada instância de classe terá a sua própria pseudo-variável &lt;code&gt;$this&lt;/code&gt; e esta, apontará para o endereço de memória onde a variável está sendo utilizada.;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;class A{&lt;/span&gt;

&lt;span class="x"&gt;    function fun(){&lt;/span&gt;
&lt;span class="x"&gt;        $this -&amp;gt; fun();&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;

&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;No código acima, definimos uma classe que contém a função &lt;code&gt;fun()&lt;/code&gt;. A função implementou uma chamada a si mesma, ou seja, utilizamos um conceito de recursividade para demonstrar que, com a variável &lt;code&gt;$this&lt;/code&gt;, temos acesso aos membros definidos internamente a classe. Se executado esse código e a função &lt;code&gt;fun()&lt;/code&gt; for invocada,a aplicação entrará em looping e ocorra o estouro da pilha que resultará na interrupção da execução do script.&lt;/p&gt;
&lt;p&gt;Estudamos que as funções possuem seu escopo restrito, isto é, as mesmas não enxergam os membros externos, da mesma forma que, os membros externos não conseguem acessar os membros definidos internamente a função.&lt;/p&gt;
&lt;p&gt;Devido ao escopo de nomes é que existe o conceito e a definição da variável &lt;code&gt;$this&lt;/code&gt;. Do contrário, não conseguiríamos acessar os membros de classe e por conseguinte, nada faria sentido!&lt;/p&gt;
&lt;p&gt;Então, para acessar um membro de classe, utilizamos a variável &lt;code&gt;$this&lt;/code&gt;, em seguida utilizamos o &lt;code&gt;-&amp;gt;&lt;/code&gt; &lt;tt class="docutils literal"&gt;operador seta&lt;/tt&gt; e por fim, o nome do membro definido pela classe.&lt;/p&gt;
&lt;p&gt;Do inglês, &lt;code&gt;this&lt;/code&gt; significa [este, esta, isto], logo, podemos concluir que a mesma tem o objetivo se fazer referência a si mesma, porém, durante o tempo de execução.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="exemplo-feito-em-aula"&gt;
&lt;h2&gt;EXEMPLO FEITO EM AULA&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;#IMPLEMENTANDO FUNÇÕES&lt;/span&gt;

&lt;span class="x"&gt;class Pessoa{&lt;/span&gt;

&lt;span class="x"&gt;    public $idade = 6;&lt;/span&gt;

&lt;span class="x"&gt;    public function get_idade(){&lt;/span&gt;

&lt;span class="x"&gt;        return $this -&amp;gt; idade;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;

&lt;span class="x"&gt;}&lt;/span&gt;

&lt;span class="x"&gt;$p1 = new Pessoa();&lt;/span&gt;
&lt;span class="x"&gt;echo $p1 -&amp;gt; get_idade();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Cláudio Rogério Carvalho Filho</dc:creator><pubDate>Wed, 15 Jun 2016 19:00:00 -0300</pubDate><guid isPermaLink="false">tag:excript.com,2016-06-15:php/pseudo-variavel-this-php.html</guid><category>curso</category><category>php</category><category>programação orientada a objetos</category><category>poo</category><category>classe</category><category>objeto</category><category>instância</category><category>blog</category></item><item><title>Herança em PHP</title><link>http://excript.com/php/heranca-php.html</link><description>
    &lt;div class="admonitionblock note data-line" style="margin-top: 1.50em"&gt;
        &lt;table style="margin: 0"&gt;
            &lt;tbody&gt;
                &lt;tr&gt;
                    &lt;td class="content" style="border-left: 0"&gt;
                        &lt;div class="paragraph data-line"&gt;
                            &lt;p&gt; Nesta aula estudaremos o conceito de herança segundo a Orientação a Objetos. Em seguida, faremos um exemplo para estudarmos a aplicação do conceito da herança em uma situação real.&lt;/p&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/tbody&gt;
        &lt;/table&gt;
    &lt;/div&gt;
&lt;div class="section" id="heranca"&gt;
&lt;h2&gt;HERANÇA&lt;/h2&gt;
&lt;p&gt;A herança representa uma das principais características da &lt;strong&gt;Orientação a Objetos&lt;/strong&gt;, até porque, somos capazes de implementar tipos de dados hierarquicamente. Através do conceito de herança, conseguimos implementar classes de uso geral, que possuam características comuns a várias entidades relacionadas.&lt;/p&gt;
&lt;p&gt;Essas classes poderão ser estendidas por outras, produzindo assim, classes mais especializadas e, que implementem funcionalidades que as tornam únicas.&lt;/p&gt;
&lt;p&gt;Através da herança, poderemos utilizar propriedades e métodos definidos na superclasse. Uma boa maneira de pensarmos neste conceito é sob a perspectiva de obter objetos mais especializados conforme aumente a hierarquia. Devemos tomar cuidado com o conceito de hereditariedade animal, até porque, os filhotes não possuem, necessariamente, as características dos pais. Já, o conceito de herança na Orientação a Objetos define que, todo herdeiro receberá o conjunto de características definidas como público e privado e, terá acesso total as funcionalidades definidas na superclasse. Assim, a única maneira de restringir os herdeiros é definindo membros privados, até porque, do contrário, todo e qualquer herdeiro poderá alterar quaisquer informação.&lt;/p&gt;
&lt;p&gt;É comum que classes derivadas sejam novamente utilizadas como base para outras. Assim, somos capazes de estender qualquer classe que não tenha o seu construtor definido como privado.&lt;/p&gt;
&lt;p&gt;Se tomarmos como exemplo a ideia de frutas, temos que a classe fruta conterá o código que define as propriedades e funções de todas as frutas, enquanto que a classe &lt;tt class="docutils literal"&gt;Maçã&lt;/tt&gt;, receberá as funções e atributos de todas as frutas, e implementará as propriedades e funções que somente as maçãs possuem.&lt;/p&gt;
&lt;p&gt;Toda &lt;strong&gt;classe poderá ser herdada&lt;/strong&gt; e para isso, não é preciso fazer nada de especial, ou seja, o uso da herança se resume a definição explicita na declaração de uma nova classe que a mesma será uma &amp;quot;continuação&amp;quot; de outra.&lt;/p&gt;
&lt;p&gt;Classes que são herdadas são chamadas de &lt;strong&gt;Classe Base&lt;/strong&gt;, &lt;strong&gt;Super&lt;/strong&gt;, &lt;strong&gt;SuperClasse&lt;/strong&gt;. Classe herdeira são chamadas de &lt;strong&gt;Classes Derivadas&lt;/strong&gt;, ou &lt;strong&gt;SubClasse&lt;/strong&gt;. Também é comum chamarmos as classes base de superclasses, e as classes que herdam desta, como sendo subclasses.&lt;/p&gt;
&lt;p&gt;O PHP não suporta herança múltipla, porém, o mesmo disponibiliza a utilização de &lt;tt class="docutils literal"&gt;traits&lt;/tt&gt;, que permite a definição de conjuntos de características. &lt;tt class="docutils literal"&gt;Traits&lt;/tt&gt; serão estudadas posteriormente e também, não podemos confundir o conceito de herança múltipla com &lt;tt class="docutils literal"&gt;traits&lt;/tt&gt;, até porque, numa análise superficial há semelhanças, mas em teoria, são conceitos distintos.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="a-sintaxe-para-uso-da-heranca"&gt;
&lt;h2&gt;A SINTAXE PARA USO DA HERANÇA&lt;/h2&gt;
&lt;p&gt;Uma classe herdeira, deverá, por definição, utilizar a instrução &lt;cite&gt;extends&lt;/cite&gt; e, em seguida, definir a classe que será estendida. O código a seguir faz uma breve demonstração da nomenclatura que deve ser utilizada.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;class Pai()&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;

&lt;span class="x"&gt;}&lt;/span&gt;

&lt;span class="x"&gt;class Filho extends Pai&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    #a classe filha utiliza a instrução `extends` e em seguida define&lt;/span&gt;
&lt;span class="x"&gt;    # o nome da classe que está sendo estendida&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Como podemos ver no trecho de código acima, a classe &lt;cite&gt;Pai&lt;/cite&gt; está sendo estendida pela classe de nome &lt;cite&gt;Filha&lt;/cite&gt; e, para isso, utilizou-se a instrução &lt;cite&gt;extends&lt;/cite&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="como-a-subclasse-utiliza-os-membros-da-super"&gt;
&lt;h2&gt;COMO A SUBCLASSE UTILIZA OS MEMBROS DA SUPER&lt;/h2&gt;
&lt;p&gt;Toda SubClasse poderá acessar os membros da &lt;strong&gt;super&lt;/strong&gt; diretamente, como se estes membros tivessem sido declarados em seu corpo. Segundo a teoria da Orientação a Objetos, toda classe herdeira deve ter acesso direto ao membros públicos e protegidos da super.&lt;/p&gt;
&lt;p&gt;Assim, salvo se lermos o código, não será possível saber em qual nível hierarquico que determinado membro foi definido.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;class SuperClasse {&lt;/span&gt;

&lt;span class="x"&gt;    public $a = &amp;#39;variável $a&amp;#39;;&lt;/span&gt;

&lt;span class="x"&gt;    public function ola()&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        echo &amp;quot;SuperClasse-&amp;gt;ola()&amp;quot;;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;

&lt;span class="x"&gt;class SubClasse extends SuperClasse {&lt;/span&gt;

&lt;span class="x"&gt;    #nada será declarado na SubClasse a fim de melhor entendermos&lt;/span&gt;
&lt;span class="x"&gt;    # o funcionamento da herança de propriedades e funcionalidades&lt;/span&gt;

&lt;span class="x"&gt;}&lt;/span&gt;

&lt;span class="x"&gt;$super = new SuperClasse();&lt;/span&gt;
&lt;span class="x"&gt;$super-&amp;gt;ola();&lt;/span&gt;
&lt;span class="x"&gt;$super-&amp;gt;a = 10;&lt;/span&gt;

&lt;span class="x"&gt;$sub = new SubClasse();&lt;/span&gt;
&lt;span class="x"&gt;$sub-&amp;gt;ola();&lt;/span&gt;
&lt;span class="x"&gt;$sub-&amp;gt;a = 10;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a class="reference external" href="http://excript.com/php/visibilidade-funcao-php.html"&gt;A visibilidade dos membros de classe será estudada em detalhes em aulas posteriores&lt;/a&gt;, porém, desde já tenha em mente que, classes herdeiras só são privadas de acessar os membros definidos como &lt;code&gt;private&lt;/code&gt;, isto é, definidos como sendo privado!&lt;/p&gt;
&lt;p&gt;No geral, todo herdeiro &lt;strong&gt;deve possuir acesso&lt;/strong&gt; aos demais membros, sejam eles públicos ou protegidos.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="heranca-na-pratica"&gt;
&lt;h2&gt;HERANÇA NA PRÁTICA&lt;/h2&gt;
&lt;p&gt;Agora, vamos implementar as classes de &lt;strong&gt;Pessoa Física&lt;/strong&gt; e &lt;strong&gt;Pessoa Jurídica&lt;/strong&gt; e, ambas serão herdeiras da classe &lt;tt class="docutils literal"&gt;Pessoa&lt;/tt&gt;. A ideia é que a classe &lt;tt class="docutils literal"&gt;Pessoa&lt;/tt&gt; implemente o que é de uso comum entre as 2 definições de pessoas: física ou jurídicas. Enquanto que as classe PF e PJ implementem somente as informações referentes ao seu tipo de pessoa.&lt;/p&gt;
&lt;p&gt;A ideia é ter um tipo de pessoa genérica e também, as pessoas especializadas, isso porque, um PF poderia, por exemplo, ser um paciente, um cliente, um vendedor, logo, seremos capazes de saber, por exemplo, as várias finalidades referentes a uma mesma Pessoa. Da mesma forma, temos que um PJ poderia ser um fornecedor, uma revenda, um cliente e etc.&lt;/p&gt;
&lt;p&gt;É interessante observar que, um cliente, normalmente, pode ser tanto PF como também PJ. Assim, ao implementarmos o cadastro de Clientes, temos que disponibilizar ambas as opções o que atrapalhará o desenvolvimento. Por outro lado, uma mesma pessoa por ter 2 razões sociais, isto é, 2 CNPJ distintos e assim, a pessoa de maneira geral será a mesma para as 2 pessoas jurídicas distintas.&lt;/p&gt;
&lt;p&gt;Existem alguma nomenclaturas distintas que encontraremos na literatura especializada da relação entre níveis diferentes das classes. Todas as terminologias aqui utilizadas forma retiradas do &lt;a class="reference external" href="http://excript.com/dicionario/indice.html"&gt;dicionário técnico eXcript&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Herança: capacidade de herdar as características de outra classe
Classe: projeto de todo objeto - instância
SuperClasse: a classe pai; classe que esta sendo estendida.
SubClasse: nome da classe que está implementando outra.
Classe-pai: classe utilizada como base para a criação de outras.
Classe-base: sinônimo a SuperClasse&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="exemplo-feito-em-aula"&gt;
&lt;h2&gt;EXEMPLO FEITO EM AULA&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;# HERANÇA I&lt;/span&gt;

&lt;span class="x"&gt;class SuperClasse{&lt;/span&gt;

&lt;span class="x"&gt;    public $a = &amp;#39;variável $a&amp;#39;;&lt;/span&gt;

&lt;span class="x"&gt;    public function ini(){&lt;/span&gt;
&lt;span class="x"&gt;        echo &amp;quot;SuperClasse-&amp;gt;ini()&amp;quot;;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;

&lt;span class="x"&gt;class SubClasse extends SuperClasse{&lt;/span&gt;

&lt;span class="x"&gt;}&lt;/span&gt;

&lt;span class="x"&gt;$super = new SuperClasse();&lt;/span&gt;
&lt;span class="x"&gt;$super-&amp;gt;ini();&lt;/span&gt;
&lt;span class="x"&gt;$super-&amp;gt;a = &amp;quot;&amp;quot;;&lt;/span&gt;

&lt;span class="x"&gt;$sub = new SubClasse();&lt;/span&gt;
&lt;span class="x"&gt;$sub-&amp;gt;ini();&lt;/span&gt;
&lt;span class="x"&gt;$sub-&amp;gt;a = &amp;quot;qualquer valor&amp;quot;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Cláudio Rogério Carvalho Filho</dc:creator><pubDate>Sat, 11 Jun 2016 06:10:00 -0300</pubDate><guid isPermaLink="false">tag:excript.com,2016-06-11:php/heranca-php.html</guid><category>curso</category><category>php</category><category>programação orientada a objetos</category><category>poo</category><category>herança</category><category>encapsulamento</category><category>classe</category><category>objeto</category><category>instância</category><category>blog</category></item><item><title>Gerenciando Atributos de Classe em PHP</title><link>http://excript.com/php/gerenciando-atributos-classe-php.html</link><description>
    &lt;div class="admonitionblock note data-line" style="margin-top: 1.50em"&gt;
        &lt;table style="margin: 0"&gt;
            &lt;tbody&gt;
                &lt;tr&gt;
                    &lt;td class="content" style="border-left: 0"&gt;
                        &lt;div class="paragraph data-line"&gt;
                            &lt;p&gt; Nesta aula aprenderemos a utilizar funções para atribuir valores a propriedades das classes e dessa forma, gerenciar qual o valor que será atribuído.&lt;/p&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/tbody&gt;
        &lt;/table&gt;
    &lt;/div&gt;
&lt;div class="section" id="definindo-valores-a-variaveis-com-funcoes"&gt;
&lt;h2&gt;DEFININDO VALORES A VARIÁVEIS COM FUNÇÕES&lt;/h2&gt;
&lt;p&gt;Propriedades que possuem regras, deveram utilizar funções para a definição de valores e, a razão para essa metodologia é bastante simples: com funções conseguimos analisar se o valor passado é, por exemplo, inválido.&lt;/p&gt;
&lt;p&gt;Se tivessemos por exemplo uma classe de nome Pessoa, cujo objetivo é conter os dados pessoais, é correto permitir a definição do nome da pessoa como sendo uma String com 0 caracteres? Normalmente não, porém, obviamente que você possa imaginar alguma situação necessário, porém, falando de forma geral, o nome de uma pessoa não deveria ter 0 caracteres ou então, ser composto por digitos numéricos.&lt;/p&gt;
&lt;p&gt;Os atributos, como estudamos, são simples variáveis, logo, podemos por exemplo restringir o acesso direto a esse membro e definir 2 funções, uma para a definição de valores e outra para a leitura. Dessa maneira, permitimos o acesso externo ao membro e ao mesmo tempo, somos capazes de analisar o valor que está sendo atribuido e processar o valor que será retornado.&lt;/p&gt;
&lt;p&gt;Nesse momento o nosso objetivo é estudar a passagem dos valores dos atributos através do uso de funções. Isso porque, &lt;a class="reference external" href="http://excript.com/php/funcoes-modificadoras-php.html"&gt;a utilização de funções para a leitura e escrita de valores representa uma metodologia de desenvolvimento e por isso, haverá no mínimo uma aula dedicada ao seu estudo&lt;/a&gt; .&lt;/p&gt;
&lt;p&gt;Ainda que não exista uma regra, é comum que funções que definem valores a atributos de classe utilizem o prefixo &lt;strong&gt;set&lt;/strong&gt;, da mesma forma, funções que retornam valores, geralmente utilizam o prefixo &lt;strong&gt;get&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="exemplo-feito-em-aula"&gt;
&lt;h2&gt;EXEMPLO FEITO EM AULA&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;#GERENCIANDO PROPRIEDADES&lt;/span&gt;

&lt;span class="x"&gt;class Pessoa{&lt;/span&gt;

&lt;span class="x"&gt;    public $idade = 0;&lt;/span&gt;

&lt;span class="x"&gt;    public function get_idade(){&lt;/span&gt;
&lt;span class="x"&gt;        return $this -&amp;gt; idade;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;

&lt;span class="x"&gt;    public function set_idade($idade){&lt;/span&gt;
&lt;span class="x"&gt;        if($idade &amp;gt; 0){&lt;/span&gt;
&lt;span class="x"&gt;            $this-&amp;gt;idade = $idade;&lt;/span&gt;
&lt;span class="x"&gt;        }else{&lt;/span&gt;
&lt;span class="x"&gt;            echo &amp;quot;A idade informada é inválida.&amp;quot;;&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;//    get - pegar&lt;/span&gt;
&lt;span class="x"&gt;//    set - definir, atribuir a, setar&lt;/span&gt;

&lt;span class="x"&gt;}&lt;/span&gt;

&lt;span class="x"&gt;$p1 = new Pessoa();&lt;/span&gt;
&lt;span class="x"&gt;$p1 -&amp;gt; set_idade(22);&lt;/span&gt;
&lt;span class="x"&gt;$p1 -&amp;gt; set_idade(-5);&lt;/span&gt;
&lt;span class="x"&gt;echo &amp;quot;A idade é: {$p1-&amp;gt;get_idade()}&amp;quot;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Cláudio Rogério Carvalho Filho</dc:creator><pubDate>Sat, 11 Jun 2016 05:00:00 -0300</pubDate><guid isPermaLink="false">tag:excript.com,2016-06-11:php/gerenciando-atributos-classe-php.html</guid><category>curso</category><category>php</category><category>programação orientada a objetos</category><category>poo</category><category>classe</category><category>objeto</category><category>instância</category><category>propriedade</category><category>atributo</category><category>blog</category></item><item><title>Herança com PHP II</title><link>http://excript.com/php/heranca-php-ii.html</link><description>
    &lt;div class="admonitionblock note data-line" style="margin-top: 1.50em"&gt;
        &lt;table style="margin: 0"&gt;
            &lt;tbody&gt;
                &lt;tr&gt;
                    &lt;td class="content" style="border-left: 0"&gt;
                        &lt;div class="paragraph data-line"&gt;
                            &lt;p&gt; Nesta aula daremos continuidade ao estuda da herança, a definição de subclasses e as características das classes-filhas.&lt;/p&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/tbody&gt;
        &lt;/table&gt;
    &lt;/div&gt;
&lt;div class="section" id="subclasse"&gt;
&lt;h2&gt;SUBCLASSE&lt;/h2&gt;
&lt;p&gt;Chamamos de &lt;strong&gt;Sub Classe&lt;/strong&gt; todas as classes herdeiras. O conceito de SubClasse é o da especialização, isto é, a SubClasse possui todas as características e funcionalidades da Super e agora irá definir um outro conjunto de funções e propriedades a fim de especializar algum conceito. É importante observar que toda SubClasse possui acesso aos membros públicos e protegidos da SuperClasse, porém o inverso não é verdadeiro.&lt;/p&gt;
&lt;p&gt;Toda SubClasse recebe os membros não privados e protegidos da super classe. Isso faz com que a subclasse torne-se capaz de fazer uso de todas funções, como também, atribuir valores às variáveis definidas na super. Toda SubClasse, por definição, será &lt;strong&gt;também&lt;/strong&gt; do tipo da SuperClasse, ou seja, se tivermos as classe A e B, onde B é subclasse de A, nós temos que B será do tipo B, e também do tipo A.&lt;/p&gt;
&lt;p&gt;Num primeiro momento a definição e utilização de SubClasse não possui quaisquer diferença no que estudamos até agora, isso porque, temos que sempre ter em mente que &lt;strong&gt;TODA&lt;/strong&gt; classe deriva obrigatoriamente de alguma SuperClasse, até porque, toda classe possui propriedades e funcionalidades por padrão, mesmo que estas sejam conceitos implicitos.&lt;/p&gt;
&lt;p&gt;Fato é que não haverá maiores problemas na SubClasse se está não vier a estender as definições da sua SuperClasse. Do contrário, isto é, se a Sub implementar uma variável o função de mesmo nome implementado na Super, o que acontecerá? Há diversas situações onde a SubClasse precisará alterar somente o funcionamento de uma função, isto é, precisará modificar o funcionamento de uma função. Outras vezes, a função não precisará ser redefinida, somente estendida. Como sabemos, a herança é uma característica das classes e não das funções e propriedades.&lt;/p&gt;
&lt;p&gt;A implementação da subclasse requer que conheçamos alguns conceitos relacionados ao compartilhamento de propriedades em níveis hierárquicos distintos.&lt;/p&gt;
&lt;p&gt;Por exemplo, vamos fazer algumas suposições, ainda que não vamos, nesse momento, estudar como resolver os problemas propostos.&lt;/p&gt;
&lt;p&gt;O que acontece se a classe derivada declara uma variável de mesmo nome declarada na classe base?
O que acontece se a classe derivada, declara uma funções de mesmo nome?
Estudamos que os construtores são invocados pela Máquina Virtual do PHP, ou seja, se tentarmos invocar o construtor pelo seu nome, um erro ocorrerá. Então, se a superclasse tem implementado um construtor e a subclasse também o implementou, ao criarmos uma instância da classe derivada, o que acontecera:&lt;/p&gt;
&lt;blockquote&gt;
a) o construtor que será invocado, será o da superclasse ou da subclasse?
c) ambos construtores serão invocados?&lt;/blockquote&gt;
&lt;p&gt;Acabamos de elucidar algumas situações que &lt;strong&gt;irão ocorrer, e ocorrerão muitas vezes&lt;/strong&gt;, quando estivermos trabalhando com a orientação a objetos. Isso significa que de agora em diante, o nosso estudo se ampliara, até porque, ao interagirmos com classes derivadas, estaremos também, interagindo com a classe base.&lt;/p&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;Um conceito simples mas importante é que a classe derivada deve se integrar com a classe base, jamais o contrário. Se houver problemas na implementação da classe derivada e a solução que encontrarmos é a alteração da superclasse, teremos uma de 2 situações:&lt;/dt&gt;
&lt;dd&gt;&lt;ol class="first last arabic simple"&gt;
&lt;li&gt;a superclasse está mau implementada&lt;/li&gt;
&lt;li&gt;a solução por nós encontrada é um problema conceitual&lt;/li&gt;
&lt;/ol&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;Como veremos de agora em diante, a POO propriamente dita é bastante simples e é quase que uma decoreba, o grande problema, pra não dizer o início do inferno, será totalmente conceitual, de análise da informação, das relações entre os tipos de dados e de como estes se relacionam. A implementação do código se tornará um simples detalhe decorrente, na maioria das vezes, de um grande estudo e análise!&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="exemplo-feito-em-aula"&gt;
&lt;h2&gt;EXEMPLO FEITO EM AULA&lt;/h2&gt;
&lt;!-- Como a subclasse implementa suas próprias funcionalidades? --&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;class SuperClasse {&lt;/span&gt;

&lt;span class="x"&gt;    public $a = 0;&lt;/span&gt;

&lt;span class="x"&gt;    public function super()&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        echo $a;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;

&lt;span class="x"&gt;class SubClasse extends SuperClasse {&lt;/span&gt;

&lt;span class="x"&gt;    public $a;&lt;/span&gt;

&lt;span class="x"&gt;    public function sub()&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        this-&amp;gt;$a = 10;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;


&lt;span class="x"&gt;$sub = new SubClasse();&lt;/span&gt;
&lt;span class="x"&gt;$sub-&amp;gt;sub();&lt;/span&gt;
&lt;span class="x"&gt;$sub-&amp;gt;super();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Cláudio Rogério Carvalho Filho</dc:creator><pubDate>Sat, 11 Jun 2016 04:15:00 -0300</pubDate><guid isPermaLink="false">tag:excript.com,2016-06-11:php/heranca-php-ii.html</guid><category>curso</category><category>php</category><category>programação orientada a objetos</category><category>poo</category><category>herança</category><category>encapsulamento</category><category>classe</category><category>objeto</category><category>instância</category><category>blog</category></item><item><title>Acessando Membros de Classe em PHP</title><link>http://excript.com/php/acessando-membros-classe-php.html</link><description>
    &lt;div class="admonitionblock note data-line" style="margin-top: 1.50em"&gt;
        &lt;table style="margin: 0"&gt;
            &lt;tbody&gt;
                &lt;tr&gt;
                    &lt;td class="content" style="border-left: 0"&gt;
                        &lt;div class="paragraph data-line"&gt;
                            &lt;p&gt; Nesta aula estudaremos o acesso a membros de classe, como devemos implementar, quais as restrições que devemos impor e demais características dessa definição.&lt;/p&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/tbody&gt;
        &lt;/table&gt;
    &lt;/div&gt;
&lt;div class="section" id="o-que-sao-membros-de-classe"&gt;
&lt;h2&gt;O QUE SÃO MEMBROS DE CLASSE&lt;/h2&gt;
&lt;p&gt;Um membro de classe é toda variável ou função definida e implementada pela classe. Assim, temos que todos os atributos e métodos que estiverem definidos numa classe são chamados de &amp;quot;membros de classe&amp;quot;. Para acessarmos os membros de uma classe, temos que utilizar a seguinte nomenclatura:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;referência + nome_membro&lt;/span&gt;
&lt;span class="x"&gt;referência -&amp;gt; nome_membro&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Temos sempre que pensar no conceito de referência, ou seja, uma variável é somente uma referência a um objeto. Assim, temos que todas as instância que criarmos de uma classe poderão acessar os membros públicos através da definição acima.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="o-conceito-de-referencia"&gt;
&lt;h2&gt;O CONCEITO DE REFERÊNCIA&lt;/h2&gt;
&lt;p&gt;Referência é para o PHP o que o endereço é para o C++, ou seja, um valor que está apontando para uma região em que há informações armazenadas. O conceito de referência em PHP não é explicito, até porque, não conseguimos obter esse endereço facilmente. Mesmo assim, não é difícil imaginar que &lt;strong&gt;tudo&lt;/strong&gt; precisa estar armazenado em algum lugar, logo, a referência é a nomenclatura que utilizamos de forma genérica para dizer que a variável A está ligada a determinada informação.&lt;/p&gt;
&lt;p&gt;É preciso entender que toda variável está armazenada na memória, bem como todo objeto. Entendido isso, é preciso entender que é utilizado uma variável para guardar a região em que determinado objeto está armazenado. Logo, você talvez se pergunte quem armazena o local de memória em que as variáveis estão, e a resposta é: o interpretador, a máquina virtual do PHP.&lt;/p&gt;
&lt;p&gt;Se entendido o conceito de referência, o conceito sobre a variável &lt;tt class="docutils literal"&gt;this&lt;/tt&gt; fica fácil de ser compreendido, até porque, está é uma variável que é criada para cada novo objeto e, só pode ser utilizada para o acesso de dentro do escopo da classe. Por isso é que dizemos que a pseudo-variável $this &lt;strong&gt;sempre&lt;/strong&gt; estará se referindo a classe em que estamos trabalhando.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;//internamente&lt;/span&gt;
&lt;span class="x"&gt;$this-&amp;gt;nome_do_membro;&lt;/span&gt;

&lt;span class="x"&gt;//externamente&lt;/span&gt;
&lt;span class="x"&gt;$variavel-&amp;gt;nome_do_membro;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="acessando-membros-de-classe"&gt;
&lt;h2&gt;ACESSANDO MEMBROS DE CLASSE&lt;/h2&gt;
&lt;p&gt;Todo objeto criado é único, ocupa um espaço reservado na memória, possui uma referência que o identifica e, por essas definições, tem-se que todo objeto é diferente dos demais e seus atributos,, no caso, as variáveis definidas pela classe, também serão únicas e ocuparão um espaço reservado de memória.&lt;/p&gt;
&lt;p&gt;Quando criamos 2 objetos de uma mesma classe, cada um possuirá um endereço que o identifica na memória e estes, não estarão compartilhando absolutamente nada - salvo se definirmos explicitamente o contrário.&lt;/p&gt;
&lt;p&gt;Então, se tivermos uma classe que definiu 10 variáveis em seu corpo, nós teremos, a cada novo objeto, 10 variáveis pra cada nova instância criada. E essas 10 variáveis que, estão contidas em cada um dos objetos, só poderão ser acessadas através da variável que possui a referência para o objeto. Logo, é possível deduzir que para fazer acesso a um membro de um objeto é preciso, antes de mais nada, especificar a qual objetos estamos nos referindo.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="acessando-atributos-de-objeto"&gt;
&lt;h2&gt;ACESSANDO ATRIBUTOS DE OBJETO&lt;/h2&gt;
&lt;p&gt;Definimos uma classe, criamos objetos, porém, até agora, não atribuimos valores às variáveis definidas na classe e que, estão disponíveis em cada instância.&lt;/p&gt;
&lt;p&gt;Um objeto pode ser utilizado de várias maneira e para diferentes propósitos, assim, podemos trabalhar com objeto para encapsular informações ou então, para simplesmente agruparmos um conjunto de variáveis. Dessa forma, temos que todos atributos contidos num objeto, passam a ser acessado através de um namespace, isto é, um nome que o identica dentro de um projeto, até porque, é dessa maneira que somos obrigados a acessar os membros de classe.&lt;/p&gt;
&lt;p&gt;Para entender o que foi dito acima, vamos pensar inicialmente que ao criarmos um objeto é preciso dizer onde a classe deste está definida, ou seja, programada. Toda classe está definida dentro de arquivos de código com extensão *.php e todo arquivo está, obrigatoriamente, contido dentro de uma pasta. O namespace de uma classe é o caminho &lt;strong&gt;PATH&lt;/strong&gt; até o local onde o arquivo *.php está armazenado mais o nome da classe.&lt;/p&gt;
&lt;p&gt;Podemos concluir que todo objeto existente é o resultado da execução de um projeto, a classe. Toda classe está contida num arquivo *.php e todo arquivo *.php está contido numa pasta. Logo, temos de dizer, no momento de criação de um objeto, o namespace da classe. Porém, para acessarmos os membros de um objeto, bastará utilizarmos a referência e em seguida, especificar o nome do membro que desejamos acessar.&lt;/p&gt;

    &lt;div class="admonitionblock important data-line-21"&gt;
        &lt;table&gt;
            &lt;tbody&gt;
                &lt;tr&gt;
                &lt;td class="icon"&gt;
                    &lt;i class="fa icon-important" title="Importante!"&gt;&lt;/i&gt;
                &lt;/td&gt;
                &lt;td class="content"&gt;
                    &lt;div class="paragraph data-line-22"&gt;
                        &lt;p&gt;É importante lembrar que só é possível acessar membros públicos!&lt;/p&gt;
                    &lt;/div&gt;
                &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/tbody&gt;
        &lt;/table&gt;
    &lt;/div&gt;
&lt;p&gt;O acesso aos atributos públicos de um objeto ocorre de maneira análoga a forma em que manipulamos variáveis, porém agora, temos de especificar em qual instância a variável que desejamos alterar está contida.&lt;/p&gt;
&lt;p&gt;Para acessar um membro de um objeto, temos de especificar 2 coisas:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Qual objeto&lt;/li&gt;
&lt;li&gt;Qual o membro&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Utilizamos o &lt;tt class="docutils literal"&gt;operador de objeto&lt;/tt&gt;, comumente chamado de &lt;tt class="docutils literal"&gt;operador seta&lt;/tt&gt; para acessarmos membros públicos, como temos no exemplo seguinte:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;$objeto_nome -&amp;gt; propriedade_nome;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;O esquema sempre será o mesmo quando formos acessar as funções definidas pelas classes. Inicialmente informamos o objeto, em seguida colocamos o &lt;tt class="docutils literal"&gt;operador seta&lt;/tt&gt; e por fim, definimos o nome da função [ &lt;strong&gt;funcionalidade&lt;/strong&gt; ] que queremos invocar.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;$p1 = new Pessoa(); #criando um objeto de Pessoa e atribuindo a referência à variável $p1&lt;/span&gt;
&lt;span class="x"&gt;$p2 = new Pessoa();&lt;/span&gt;
&lt;span class="x"&gt;$p1-&amp;gt;nome = &amp;quot;João&amp;quot;; #acessando a variável $nome&lt;/span&gt;
&lt;span class="x"&gt;                    # definida pela classe Pessoa e por isso,&lt;/span&gt;
&lt;span class="x"&gt;                    # contida na instância $p1&lt;/span&gt;
&lt;span class="x"&gt;$p2-&amp;gt;nome = &amp;quot;Maria&amp;quot;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A utilização de objetos para gerar HTML é igual a forma com geramos páginas fazendo uso de variáveis. A diferença é que agora a variável que utilizaremos é, na verdade, um atributo de um objeto e, para extrairmos seu valores, invocaremos uma função que foi definida para este fim.&lt;/p&gt;
&lt;p&gt;No exemplo acima, criamos objetos, definimos seus atributos e por fim, extraímos as informações dos objetos criados. Mesmo que o exemplo feito não tenha qualquer utilidade prática, o conceito envolvido mostra o uso comum de objetos e geração de HTML.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="inicializando-membros-de-classe"&gt;
&lt;h2&gt;INICIALIZANDO MEMBROS DE CLASSE&lt;/h2&gt;
&lt;p&gt;Muitas propriedades de objetos precisarão ter valores iniciais para que tudo funcione corretamente. Todas as propriedades que precisam definir valores iniciais, precisaram ter seus valores atribuídos em sua declaração.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;class Quadrado&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    public $x = 5, $y = 10;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="exemplo-feito-em-aula"&gt;
&lt;h2&gt;EXEMPLO FEITO EM AULA&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;#ACESSANDO MEMBROS DE CLASSE&lt;/span&gt;

&lt;span class="x"&gt;class Pessoa{&lt;/span&gt;
&lt;span class="x"&gt;    public $idade = 0;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;

&lt;span class="x"&gt;$p1 = new Pessoa();&lt;/span&gt;
&lt;span class="x"&gt;$p2 = new Pessoa();&lt;/span&gt;

&lt;span class="x"&gt;$p1 -&amp;gt; idade = 22;&lt;/span&gt;
&lt;span class="x"&gt;$p2 -&amp;gt; idade = 15;&lt;/span&gt;

&lt;span class="x"&gt;echo $p1 -&amp;gt; idade . &amp;quot;\n&amp;quot;;&lt;/span&gt;
&lt;span class="x"&gt;echo $p2 -&amp;gt; idade;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Cláudio Rogério Carvalho Filho</dc:creator><pubDate>Fri, 10 Jun 2016 23:00:00 -0300</pubDate><guid isPermaLink="false">tag:excript.com,2016-06-10:php/acessando-membros-classe-php.html</guid><category>curso</category><category>php</category><category>programação orientada a objetos</category><category>poo</category><category>classe</category><category>membro de classe</category><category>objeto</category><category>instância</category><category>blog</category></item><item><title>Criação de Objetos em PHP</title><link>http://excript.com/php/criacao-objetos-php.html</link><description>
    &lt;div class="admonitionblock note data-line" style="margin-top: 1.50em"&gt;
        &lt;table style="margin: 0"&gt;
            &lt;tbody&gt;
                &lt;tr&gt;
                    &lt;td class="content" style="border-left: 0"&gt;
                        &lt;div class="paragraph data-line"&gt;
                            &lt;p&gt; Nesta aula estudaremos a criação de novos objetos através das classes que definimos em PHP. Aprenderemos as diferenças entre classe, objeto e instâncias, bem como as demais definições envolvidas.&lt;/p&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/tbody&gt;
        &lt;/table&gt;
    &lt;/div&gt;
&lt;div class="section" id="criando-objetos-e-acessando-membros-de-classe"&gt;
&lt;h2&gt;CRIANDO OBJETOS E ACESSANDO MEMBROS DE CLASSE&lt;/h2&gt;
&lt;!-- Para acessarmos os membros de uma classe, primeiro é necessário criar a mesma --&gt;
&lt;p&gt;As classes são os projetos de como os objetos devem funcionar quando criados. Então, temos que entender que a classe é o nosso código propriamente dito e, para que este tenha alguma utilidade, precisamos criar uma instância do mesmo. Observe que na orientação a objetos, instância e objeto são sinônimos.&lt;/p&gt;
&lt;p&gt;Se consultarmos o dicionário Aurélio o significado de instância, teremos varias definições, dentre estas há o significado de instância na computação e o mesmo diz que:&lt;/p&gt;

    &lt;div class="admonitionblock tip data-line"&gt;
        &lt;table&gt;
            &lt;tbody&gt;
                &lt;tr&gt;
                    &lt;td class="icon"&gt;
                        &lt;i class="fa icon-tip" title="Dica!"&gt;&lt;/i&gt;
                    &lt;/td&gt;
                    &lt;td class="content"&gt;
                        &lt;div class="paragraph data-line"&gt;
                            &lt;p&gt;[Informática] Cada um dos objetos criados durante a execução de programa.&lt;/p&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/tbody&gt;
        &lt;/table&gt;
    &lt;/div&gt;
&lt;p&gt;Podemos concluir que, executar o código da nossa classe significa criar novos objetos.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conceitos-importantes"&gt;
&lt;h2&gt;CONCEITOS IMPORTANTES&lt;/h2&gt;
&lt;p&gt;Em qualquer disciplina que estudamos há um conjunto de princípios a serem estudados e entendidos e, com a orientação a objetos não é diferente. A grande maioria dos conceitos que estudaremos terão significado igual a de outras disciplinas, como por exemplo, o conceito de herança, logo, o que precisamos realmente entender e memorizar forma um conjunto bastante diminuto.&lt;/p&gt;
&lt;p&gt;A seguir temos a definição de 3 conceitos e, talvez, os mais importantes, haja vista que todos os demais, derivam destes.&lt;/p&gt;
&lt;p&gt;a) &lt;strong&gt;CLASSE&lt;/strong&gt;
Projeto composto por código de programação. Quando executado executado origina um objeto.&lt;/p&gt;
&lt;p&gt;b) &lt;strong&gt;OBJETO&lt;/strong&gt;
Execução do código da classe.&lt;/p&gt;
&lt;p&gt;c) &lt;strong&gt;INSTÂNCIA&lt;/strong&gt;
Sinônimo de objeto. Essa é uma forma genérica para nos referirmos a objetos criados.&lt;/p&gt;
&lt;p&gt;É muito importante entender que as variáveis não são objetos e nem instâncias, elas somente nos proporcionam uma forma para acessarmos as instâncias que estão na memória. Por isso, é errado dizer que uma variável é, por exemplo, um Carro, partindo do princípio de que temos a classe Carro.&lt;/p&gt;
&lt;p&gt;Para criarmos um objeto, temos que utilizar a instrução &lt;tt class="docutils literal"&gt;new&lt;/tt&gt; e então, definir o nome da classe que desejamos um objeto. A instrução &lt;tt class="docutils literal"&gt;new&lt;/tt&gt; tem como objetivo, informar que desejamos executar o código da nossa classe e também, que queremos a instância dessa nova classe.&lt;/p&gt;
&lt;p&gt;A instrução &lt;tt class="docutils literal"&gt;new&lt;/tt&gt; &lt;strong&gt;sempre&lt;/strong&gt; retornará a instância do objeto criado, salvo se ocorrer erros no momento da criação.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="acessando-objetos-e-seus-membros"&gt;
&lt;h2&gt;ACESSANDO OBJETOS E SEUS MEMBROS&lt;/h2&gt;
&lt;p&gt;Quando criamos um objeto precisamos ter uma forma para acessar o mesmo, por isso, é comum atribuirmos na declaração de criação de objetos, uma variável que receberá a instância do mesmo. Isto é, a criação de novos objetos estará numa instrução de atribuição, onde o lado direito será a criação do objeto e o lado esquerdo a variável que receberá o endereço da instância criada.
Em outras palavras, iremos criar um objeto e ao mesmo tempo atribuir o mesmo (a nova instância) a uma variável. Por fim, temos que entender que as variáveis representam uma forma fácil para o acesso a memória, por isso vinculamos variáveis a objetos.&lt;/p&gt;
&lt;p&gt;Também é importante observar que, se a instância retornada não for armazenada numa variável no momento da criação, não será mais possível acessar o objeto criado, ou seja, criar um novo objeto e não atribuir a instância, significa, executar o código de inicialização do objeto e em seguida, destruir o mesmo.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="destruicao-de-objetos"&gt;
&lt;h2&gt;DESTRUIÇÃO DE OBJETOS&lt;/h2&gt;
&lt;p&gt;Um objeto será destruido todas as vezes em que não houver mais variáveis contendo sua referência, isto, que esteja referenciando-o. Dessa forma, temos que o PHP desalocará a memória de todos os objetos quando estes não mais tiverem utilidade. Se por acaso tentarmos acessar um objeto que foi destruído, temos que ocorrerá um erro e o Script PHP terá sua execução finalizada, até porque, o objeto não existe mais.&lt;/p&gt;
&lt;p&gt;Porém, não se preocupe, o PHP sabe gerenciar muito bem a memória e também, consegue definir com bastante precisão o momento de remover cada instância da memória. Por isso, salvo em raras exceções, você irá ter problemas com a destruição de objetos que ainda estavam em uso.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;$p1 = new Pessoa();&lt;/span&gt;
&lt;span class="x"&gt;$p2 = new Pessoa();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="garbage-collector"&gt;
&lt;h2&gt;GARBAGE COLLECTOR&lt;/h2&gt;
&lt;p&gt;O &lt;strong&gt;Garbage Collector&lt;/strong&gt; é o responsável por desalocar a memória utilizada. A forma de funcionamento do mesmo se dá pelo compartilhamento de uma variável que, a cada nova variável que fizer referência a determinada instância, o valor da variável compartilhada é incrementado e, a cada instância referenciada por uma variável que for destruída, tem o seu valor decrementado. Quando este valor for igual a 0 a instância é removida da memória.&lt;/p&gt;
&lt;p&gt;Observe que estamos falando em instância, isto é, em objetos e não em Classes. Logo, o Garbage Collector não gerencia a quantidade de instâncias criadas, mas sim, &lt;strong&gt;a quantidade de variáveis que apontam para uma instância&lt;/strong&gt;!&lt;/p&gt;
&lt;p&gt;Se você tiver dificuldade no entendimento deste conceito não há problema, até porque, basta saber que, todas as vezes que não houver mais variáveis fazendo referência a um objeto o mesmo será destruido!&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="exemplo-feito-em-aula"&gt;
&lt;h2&gt;EXEMPLO FEITO EM AULA&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;#CRIAÇÃO DE OBJETOS/INSTÂNCIAS&lt;/span&gt;

&lt;span class="x"&gt;class Classe{&lt;/span&gt;
&lt;span class="x"&gt;    public $a = 1;&lt;/span&gt;
&lt;span class="x"&gt;    public $b = 2;&lt;/span&gt;
&lt;span class="x"&gt;    public $c = 3;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;

&lt;span class="x"&gt;$objetoA = new Classe();&lt;/span&gt;
&lt;span class="x"&gt;$objetoB = new Classe();&lt;/span&gt;
&lt;span class="x"&gt;$objetoC = new Classe();&lt;/span&gt;

&lt;span class="x"&gt;var_dump($objetoA);&lt;/span&gt;
&lt;span class="x"&gt;//var_dump($objetoB);&lt;/span&gt;
&lt;span class="x"&gt;//var_dump($objetoC);&lt;/span&gt;

&lt;span class="x"&gt;unset($objetoA);&lt;/span&gt;
&lt;span class="x"&gt;var_dump($objetoA);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Cláudio Rogério Carvalho Filho</dc:creator><pubDate>Fri, 10 Jun 2016 21:00:00 -0300</pubDate><guid isPermaLink="false">tag:excript.com,2016-06-10:php/criacao-objetos-php.html</guid><category>curso</category><category>php</category><category>programação orientada a objetos</category><category>poo</category><category>classe</category><category>objeto</category><category>instância</category><category>blog</category></item><item><title>A Orientação a Objetos em PHP</title><link>http://excript.com/php/orientacao-a-objetos-em-php.html</link><description>
    &lt;div class="admonitionblock note data-line" style="margin-top: 1.50em"&gt;
        &lt;table style="margin: 0"&gt;
            &lt;tbody&gt;
                &lt;tr&gt;
                    &lt;td class="content" style="border-left: 0"&gt;
                        &lt;div class="paragraph data-line"&gt;
                            &lt;p&gt; Nesta aula teremos uma introdução à Programação Orientada a Objeto e, estudaremos os principais conceitos relacionados.&lt;/p&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/tbody&gt;
        &lt;/table&gt;
    &lt;/div&gt;
&lt;div class="section" id="introducao"&gt;
&lt;h2&gt;INTRODUÇÃO&lt;/h2&gt;
&lt;p&gt;A &lt;strong&gt;Orientação a Objetos&lt;/strong&gt; é uma paradigma de programação, isto é, uma metodologia para o desenvolvimento de software. A definição de orientação, utilizando a definição como sendo um Verbo transitivo direto e indireto, significa, determinar a posição, orientar, indicar o rumo, guiar, dirigir, nortear. Objeto, por sua vez, é tudo que pode ser manipulado, possui características e desempenha funcionalidades.&lt;/p&gt;
&lt;p&gt;Podemos aferir que o termo &lt;strong&gt;Orientação&lt;/strong&gt; é o modelo utilizado, o que norteará tudo e, &lt;strong&gt;objeto&lt;/strong&gt;, a definição de cada parte do modelo.&lt;/p&gt;
&lt;p&gt;Segundo a análise das definições acima a respeito de &lt;strong&gt;orientação&lt;/strong&gt; e de &lt;strong&gt;objeto&lt;/strong&gt;, podemos aferir também que o &lt;strong&gt;Paradigma Orientado a Objetos&lt;/strong&gt; é o modelo de projeto onde todas as informações serão definidas e utilizadas como sendo objetos, isto é, entidades representativas, ou então, podemos dizer que tudo tornar-se-á objetos e poderá ser manipulado como sendo uma entidade.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="a-filosofia-e-a-orientacao-a-objetos"&gt;
&lt;h2&gt;A FILOSOFIA E A ORIENTAÇÃO A OBJETOS&lt;/h2&gt;
&lt;p&gt;O estudo teórico da orientação a objeto está recheado de conceitos filosóficos e suas definições. A primeira, evidentemente, é o conceito da natureza do objeto. Comumente, diz-se que objeto é tudo que é físico e que pode ser visto ou então, segurado nas mãos. Porém, se falarmos sobre empresas, no plural, temos que o conceito é ou não é um objeto?&lt;/p&gt;
&lt;p&gt;Para a filosofia clássica, o plural é um conceito abstrato e que só existirá se houver, antes de tudo, alguma empresa fisicamente. A programação orientada a objetos analisa, geralmente, o conceito de empresa abstrato. Da mesma forma podemos perguntar o que é uma floresta? Floresta é a observação de arvores independentes observadas como pertences a um conjunto, no caso - a floresta.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="objeto"&gt;
&lt;h2&gt;OBJETO&lt;/h2&gt;
&lt;p&gt;Em nosso mundo, &lt;strong&gt;objeto&lt;/strong&gt; é tudo que é físico e portanto, que pode ser manipulado. Tudo que é físico possui, por definição do termo &lt;strong&gt;físico&lt;/strong&gt; características e portanto, pode desempenhar atividades.&lt;/p&gt;
&lt;p&gt;Se tomarmos como exemplo uma pedra, temos que está é um objeto, existe fisicamente, possui propriedades e, pode desempenhar alguma função. Toda pedra desempenha uma função? Não sei lhe dizer, mas garanto que podemos decidir que determinada pedra desempenha alguma funcionalidade. Quais as funcionalidades que uma pedrão pode desempenhar? Tudo que as suas características nos fornecerem como uma forma de utiliza-la.&lt;/p&gt;
&lt;p&gt;Toda objeto, ou melhor, todas as pedras possuem características, como por exemplo, peso, dimensão, coloração, densidade, propriedades fisico-químicas e etc. Toda característica pode ser explorada, isto é, servir para algum fim. O peso da pedra, por exemplo, pode ser utilizado para travar uma porta. A coloração de uma pedra pode ser utilizada como decoração de muros e paredes. As propriedades físico-químicas podem ser utilizadas para ativar ou desativar uma reação e assim por diante.&lt;/p&gt;
&lt;p&gt;O que precisamos entender nesse momento é que &lt;strong&gt;todo objeto&lt;/strong&gt; possui &lt;strong&gt;propriedades&lt;/strong&gt; e &lt;strong&gt;todo objeto&lt;/strong&gt; possui &lt;strong&gt;funcionalidades&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="propriedades"&gt;
&lt;h2&gt;PROPRIEDADES&lt;/h2&gt;
&lt;p&gt;Propriedade é toda e qualquer característica dos objetos. É importante saber que &lt;strong&gt;propriedade&lt;/strong&gt;, &lt;strong&gt;característica&lt;/strong&gt; e &lt;strong&gt;atributo&lt;/strong&gt; são, na orientação a objetos, sinônimos.&lt;/p&gt;
&lt;p&gt;A afirmação de que todo objeto possui propriedades é verdadeira e, aquele que disser o contrário, que demonstre o objeto que não existe, até porque, existir é a primeira propriedade de &lt;strong&gt;TODO&lt;/strong&gt; objeto que, também pode ser considerado uma funcionalidade.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="funcao"&gt;
&lt;h2&gt;FUNÇÃO&lt;/h2&gt;
&lt;p&gt;A função é aquilo que o objeto desempenha. Nem todo objeto terá definido funções explicitamente, até porque, há objetos cuja funcionalidade é guardar valores, ou seja, guardar propriedades.&lt;/p&gt;
&lt;p&gt;Todo objeto pode desempenhar 2 tipos de funcionalidades: interna e externa. Um objeto pode, por exemplo, alterar suas propriedades sem interagir com o meio em que está contido. Da mesma forma que um objeto pode alterar suas propriedades pela interação com o meio.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="informacao-vs-propriedade"&gt;
&lt;h2&gt;INFORMAÇÃO vs PROPRIEDADE&lt;/h2&gt;
&lt;p&gt;Já estudamos que todo objeto possui propriedades, agora, vamos estudar o que são realmente as propriedades.&lt;/p&gt;
&lt;p&gt;É correto dizer que os objetos físicos possuem cor. Logo, todo objeto físico deve ter a propriedade cor, porém, se analisarmos com atenção, objetos não possuem propriedades e sim uma cor propriamente dita. Parece simples e até idiota a análise, no entanto, vejamos que, o projeto de todo objeto possui propriedades, enquanto que os objetos, em sua definição, possuem por exemplo, uma cor e não uma propriedade.&lt;/p&gt;
&lt;p&gt;O que temos de entender do conceito exposto é, que a orientação a objetos, inicialmente, trabalha com o projeto de como será cada objeto, em seguida, quando houver um objeto criado através do projeto, teremos algo físico que possui características que, iremos chamar de propriedades, mesmo sabendo que somente o projeto é que possui a definição de propriedade.&lt;/p&gt;
&lt;p&gt;Podemos resumir todo o exposto pela análise do conjunto e da unidade. A POO faz com que criemos entidades representativas e, nos obriga a definir as propriedades e funcionalidades dessas entidades. Podemos dizer então, que num primeiro momento estaremos trabalhando com o conjunto, isto é, definimos as características e funcionalidades que &lt;strong&gt;todos&lt;/strong&gt; objetos criados terão. Em seguida, após definir o projeto, escreveremos que desejamos que seja criado um objeto e que este possua determinados valores segundo as propriedades anteriormente definidas. Assim, temos que entender as 2 fases da POO, onde a primeira será a definição do projeto e a segunda a utilização propriamente dita.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="objetos-especializados"&gt;
&lt;h2&gt;OBJETOS ESPECIALIZADOS&lt;/h2&gt;
&lt;p&gt;Especialização é o aprimoramento de determinada característica. Se estudarmos as frutas, inicialmente iremos definir o conceito de fruta propriamente dito. Em seguida, iremos por exemplo, estudar as melancias que são, antes de mais nada frutas, porém, possuem características únicas.&lt;/p&gt;
&lt;p&gt;A análise de frutas de maneira geral é o projeto pelo qual todas as frutas são baseadas, logo, é correto dizer que, todas as frutas possuem um conjunto de características e funcionalidades iguais. Assim, quando formos definir o projeto da melancia iremos utilizar como base o projeto das frutas, do contrário, teremos projetos redundantes.&lt;/p&gt;
&lt;p&gt;O projeto das melancias terá definições que toda melancia possui, logo, quando criarmos uma melancia através deste projeto, teremos um objeto que é, ao mesmo tempo uma fruta e uma melancia. Isso porque, a melancia foi projetada se valendo do projeto das frutas, logo, toda melancia é uma fruta, mas nem toda fruta será uma melancia.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="definicao-de-objetos-que-nao-sao-objetos"&gt;
&lt;h2&gt;DEFINIÇÃO DE OBJETOS QUE NÃO SÃO OBJETOS&lt;/h2&gt;
&lt;p&gt;O estudo filosófico da OO é sem dúvida intrigante, até porque, o mesmo nos orienta a representar toda e qualquer informação como sendo entidades isoladas. Porém, muitas serão as entidades que precisaremos criar uma representação física, porém, no mundo real, a mesma possui uma definição abstrata.&lt;/p&gt;
&lt;p&gt;Tomemos por exemplo o setor de RH e a necessidade de informatizar o mesmo. Para isso, nossa primeira atividade será, o estudo de como o setor funciona. Vamos criar uma situação hipotética para facilitar o estudo.&lt;/p&gt;
&lt;p&gt;Observamos que o setor de RH faz o cadastro dos colaboradores. O RH também gerencia aqueles que desejam se tornar colaboradores. O RH define o salário e a função de cada colaborador e, conforme a função definida pelo RH para determinado colaborador, este terá acesso as várias partes do nosso programa.&lt;/p&gt;
&lt;p&gt;Então, concluimos que, o setor de RH precisa, num primeiro momento de um cadastro de colaboradores e de um cadastro daqueles que desejam tornar-se colaboradores. Logo, desenhamos num papel que:&lt;/p&gt;
&lt;p&gt;Colaboradores
* Nome
* Idade
* Cargo
* Ativo/Demitido
* Data admissão&lt;/p&gt;
&lt;p&gt;Acabamos de definir algumas propriedades dos colaboradores, e coloca-mo-as numa espécie de lista. Assim, temos as propriedades, agora, quais seriam as funções desses colaboradores? Nesse momento vamos deixar essa resposta em aberto.&lt;/p&gt;
&lt;p&gt;Vamos supor que tenhamos programado um cadastro que contenha a lista de informações elucidadas para os Colaboradores. Esse cadastro nos forneceu a capacidade de Incluir, Alterar e Excluir Colaboradores. Até esse momento, o nosso trabalho foi a implementação de algo que ocorre fisicamente, isto é, quando não há um sistema informatizado, há papeis, formulários físicos que são utilizados para este fim.&lt;/p&gt;
&lt;p&gt;Agora vamos supor que um Colaborar tenha sido demitido, logo, vamos marcar o campo Ativo como sendo igual a Falso, até porque, o Colaborador não está ativo. Agora, vamos supor que 2 anos depois o Colaborador foi re-contratado pela empresa, logo, quando o RH for fazer o cadastro, o mesmo não poderá cadastrar alguém que já possui cadastrado, correto? Então, num primeiro momento concluímos que, o RH marque o cadastro do Colaborador como sendo ativo e num primeiro momento, passamos a acreditar que tudo está funcionando normalmente.&lt;/p&gt;
&lt;p&gt;Em um determinado dia, um chefe resolve analisar os lucros da empresa e, para isso, o mesmo utilizará o nosso sistema. Logo, o mesmo gera um relatório que contém toda a receita da empresa no ano passado menos o valor das despesas. A primeira pergunta a ser feita é: o Colaborador que teve o seu cadastrado recém ativado estará ou não no cálculo das despesas do ano que passou? Se o nosso sistema funcionar segundo a definição que acabamos de estudar, o colaborador será considerado uma despesa caso a data de admissão seja igual a data da sua primeira contratação. Porém, se alterarmos a data de admissão, este problema está resolvido! Mas, se o chefe quiser um relatório de lucro de 2 anos atrás, isto é, da época em que este colaborador estava ativo, o mesmo não entrará no relatório, até porque, a sua data de admissão foi alterada!&lt;/p&gt;
&lt;p&gt;Deste problema concluímos que, além do cadastro de colaboradores, é necessário um cadastro do período trabalhado. Agora, após a análise do problema, acabamos por ter uma informação que é totalmente abstrata e, o pior de tudo, a mesma nem possui um nome propriamente dito e a mesma nem existia na época em que não havia o nosso sistema! Obviamente que, o nosso programa irá criar uma entidade, isto é, um objeto para representar esse fenômeno, porém, na prática, a contratação e a demissão são objetos ou simplesmente ações?&lt;/p&gt;
&lt;p&gt;A moral da análise anterior é que com a POO, tudo tornar-se-á objetos, que possuirá identificador, propriedades e funcionalidades, porém, o paradoxo é que no mundo físico não há objeto de admissão e demissão, mas, no mundo virtual, onde não existem objetos físicos, haverá um objeto que conterá a definição de contratado, demitido, e em qual período ocorreu... o objeto ou a ação?&lt;/p&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Cláudio Rogério Carvalho Filho</dc:creator><pubDate>Fri, 10 Jun 2016 01:45:00 -0300</pubDate><guid isPermaLink="false">tag:excript.com,2016-06-10:php/orientacao-a-objetos-em-php.html</guid><category>curso</category><category>php</category><category>programação orientada a objetos</category><category>poo</category></item><item><title>Primeira Classe em PHP</title><link>http://excript.com/php/primeira-classe-php.html</link><description>
    &lt;div class="admonitionblock note data-line" style="margin-top: 1.50em"&gt;
        &lt;table style="margin: 0"&gt;
            &lt;tbody&gt;
                &lt;tr&gt;
                    &lt;td class="content" style="border-left: 0"&gt;
                        &lt;div class="paragraph data-line"&gt;
                            &lt;p&gt; Nesta aula implementaremos a nossa primeira classe em PHP. Também estudaremos alguns conceitos sobre a programação orientada a objetos e os seus beneficios.&lt;/p&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/tbody&gt;
        &lt;/table&gt;
    &lt;/div&gt;
&lt;div class="section" id="os-objetos-e-o-php"&gt;
&lt;h2&gt;OS OBJETOS E O PHP&lt;/h2&gt;
&lt;p&gt;Nesta aula iniciaremos o estudo da Orientação a Objetos utilizando a linguagem PHP.&lt;/p&gt;
&lt;p&gt;Inicialmente temos de saber que o PHP incorporou os conceitos da orientação a objetos e não o contrário. Ou seja, POO é uma definição para o desenvolvimento de software e que é utilizado por várias linguagens de programação de computadores. A verdade é que POO não é uma linguagem e não possui nenhuma sintaxe definida. A mesma é um conceito em que utiliza a definição de objetos do mundo real para a construção de entidades representativas que contenham informações e um conjunto de funções e métodos para a sua manipulação dessa informações.&lt;/p&gt;
&lt;p&gt;Inicialmente, o PHP dispunha somente do paradigma de programação procedural, onde as aplicações eram construídas pela definição de funções em um ou diversos arquivos e conforme necessário as funções iam sendo invocadas.&lt;/p&gt;
&lt;p&gt;Esse paradigma de programação continua sendo válido na construção de códigos e, geralmente, é a porta de entrada dos novos programadores. Até porque, num primeiro momento, a literatura e os professores de PHP ensinam a utilizar funções sem nem ao menos declararmos uma função. Ou seja, colocamos todas as funções no corpo do arquivo que possui extensão *.php e executamos no browser.&lt;/p&gt;
&lt;p&gt;Assim, é comum em PHP utilizarmos os 2 paradigmas de programação e mais um terceiro, o paradigma de programação funcional. Logo, temos que o PHP suporta, basicamente, 3 paradigmas para o desenvolvimento de Scripts e aplicativos, são eles:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Paradigma de programação procedural&lt;/li&gt;
&lt;li&gt;Paradigma de programação Orientado a Objetos&lt;/li&gt;
&lt;li&gt;Paradigma de programação funcional&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;A verdade é que não existe paradigma melhor ou pior, cada um busca servir a um propósito bem especifico e, mesmo sendo possível fazer em qualquer paradigma o que é feito em outro, a estrutura e a organização do código possui grande diferença, seja na leitura, seja na performance de sua execução.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conceito-de-classe"&gt;
&lt;h2&gt;CONCEITO DE CLASSE&lt;/h2&gt;
&lt;p&gt;Classe é um Tipo Abstrato de Dados (TAD), isto é, uma forma para declararmos um novo tipo de informação e, implementar os estados e os comportamentos do novo tipo de dado.&lt;/p&gt;
&lt;p&gt;Por definição, as classe permitem a definição de estado e de comportamento. Assim, conseguimos manter as informações e as funções que as manipulam numa mesma entidade representativa.&lt;/p&gt;
&lt;p&gt;Devemos entender o conceito de &lt;strong&gt;estado&lt;/strong&gt; como sendo os atributos, isto é, as variáveis propriamente ditas. Enquanto que o comportamento, são as funções, isto é, blocos de códigos que irão trabalhar e manipular os estados.&lt;/p&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;estado&lt;/dt&gt;
&lt;dd&gt;atributos referentes as classes&lt;/dd&gt;
&lt;dt&gt;comportamento&lt;/dt&gt;
&lt;dd&gt;funções que manipulam os estados&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;div class="section" id="primeira-classe"&gt;
&lt;h2&gt;PRIMEIRA CLASSE&lt;/h2&gt;
&lt;p&gt;Agora vamos criar a nossa primeira classe em PHP. Para isso, faremos uso da palavra-chave &lt;tt class="docutils literal"&gt;class&lt;/tt&gt; que, do Inglês, significa classe. Após o uso da instrução &lt;tt class="docutils literal"&gt;class&lt;/tt&gt;, temos que abrir e fechar chaves, definindo assim, o escopo de nomes público da classe.&lt;/p&gt;
&lt;p&gt;Isso quer dizer que todas as variáveis e funções deverão, obrigatoriamente, serem definidas entre os parêntesis que compreendem o bloco de instrução da classe, por exemplo:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;class &amp;lt; nome &amp;gt;&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;    # &amp;lt;bloco de instrução da classe&amp;gt;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;No código acima, definimos o esquema para a declaração de classes em PHP. Inicialmente, utilizamos a palavra reservada &lt;code&gt;class&lt;/code&gt;, em seguida, definimos o nome da classe e, por fim, abrimos e fechamos chaves definindo assim, o bloco de instrução que estarão contidos &lt;strong&gt;todas&lt;/strong&gt; as funções e propriedades da classe.&lt;/p&gt;
&lt;p&gt;Toda classe em POO deverá, obrigatoriamente, possuir um nome. &lt;a class="reference external" href="http://excript.com/php/nomenclatura-variavel-php.html"&gt;A composição de nomes segue as mesmas regras estudadas na definição de nomes de variáveis em PHP&lt;/a&gt; .&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="nomenclatura-convencional"&gt;
&lt;h2&gt;NOMENCLATURA CONVENCIONAL&lt;/h2&gt;
&lt;p&gt;É comum a composição de nome de classe seguindo o padrão CamelCase, isto é, a primeira letra de cada palavra deve estar em letra maiúscula. Por exemplo, &lt;tt class="docutils literal"&gt;ClasseTeste&lt;/tt&gt;. Como podemos ver, o nome fictício que definimos está composto por 2 palavras: clase e teste. Logo, para compormos um nome de classe com esses 2 termos, colaríamos as iniciais e maiúsculas e os uniriamos diretamente &lt;tt class="docutils literal"&gt;ClasseTeste&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;Obviamente que, sendo você o programador, a nomenclatura que seguirás é aquela que desejares, porém, quando outro programador for ler o seu código, o nível de dificuldade se acentuará caso não estejas utilizando algum padrão. E, se por ventura, vieres a distribuir o seu código, será importante seguir as convenções já estabelecidas, até porque, é dessa forma que a comunidade está acostumada a ler e a estudar códigos PHP.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="peculiaridade-na-nomenclatura-de-classe"&gt;
&lt;h2&gt;PECULIARIDADE NA NOMENCLATURA DE CLASSE&lt;/h2&gt;
&lt;p&gt;Aprendemos em aulas anteriores que o PHP é uma linguagem Case Sensitive, isto é, referências constituidas por letras maiúsculas e minúsculas são nomes diferentes de e fazem referência a entidades diferentes. Por exemplo:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;$nome_a = 10;&lt;/span&gt;
&lt;span class="x"&gt;$nome_A = 20;&lt;/span&gt;

&lt;span class="x"&gt;if ($nome_a == $nome_A)&lt;/span&gt;
&lt;span class="x"&gt;    echo &amp;quot;1&amp;quot;;&lt;/span&gt;
&lt;span class="x"&gt;if ($nome_A == $nome_A)&lt;/span&gt;
&lt;span class="x"&gt;    echo &amp;quot;2&amp;quot;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="exemplo-feito-em-aula"&gt;
&lt;h2&gt;EXEMPLO FEITO EM AULA&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;#PRIMEIRA CLASSE EM PHP&lt;/span&gt;

&lt;span class="x"&gt;class Pessoa{&lt;/span&gt;

&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Cláudio Rogério Carvalho Filho</dc:creator><pubDate>Wed, 01 Jun 2016 03:45:00 -0300</pubDate><guid isPermaLink="false">tag:excript.com,2016-06-01:php/primeira-classe-php.html</guid><category>curso</category><category>php</category><category>programação orientada a objetos</category><category>poo</category><category>classe</category><category>objeto</category><category>instância</category><category>blog</category></item><item><title>Membros de Classe em PHP</title><link>http://excript.com/php/membro-de-classe-php.html</link><description>
    &lt;div class="admonitionblock note data-line" style="margin-top: 1.50em"&gt;
        &lt;table style="margin: 0"&gt;
            &lt;tbody&gt;
                &lt;tr&gt;
                    &lt;td class="content" style="border-left: 0"&gt;
                        &lt;div class="paragraph data-line"&gt;
                            &lt;p&gt; Nesta aula o que são membros de classe, como defini-los e quais as características de melhores formas para defini-los e utiliza-los pelas nossas classes.&lt;/p&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/tbody&gt;
        &lt;/table&gt;
    &lt;/div&gt;
&lt;div class="section" id="adicionando-membros-a-nossa-classe-pessoa"&gt;
&lt;h2&gt;ADICIONANDO MEMBROS À NOSSA CLASSE &lt;tt class="docutils literal"&gt;PESSOA&lt;/tt&gt;&lt;/h2&gt;
&lt;p&gt;Estudamos que uma classe é um projeto e que quando executada se tornará num objeto. Assim, ao criarmos uma instância da classe, teremos um objeto construido a partir do código implementado nessa classe. Todo objeto, virtual ou físico, possui por definição do termo &amp;quot;objeto&amp;quot; atributos, ou seja, um objeto físico sempre possui uma cor, um peso, um formato e etc, já, uma objeto virtual pode ter esses atributos ou então, qualquer outro.&lt;/p&gt;
&lt;p&gt;Como estudamos, podemos definir variáveis em quaisquer parte do nosso código e utilizar estas para armazenarmos o que bem entendermos. O conceito por detrás da definição de variáveis dentro do escopo de classe é fazer com que a informação dessa variável esteja relacionada a outras informação de determinado objeto. Por isso a definição de propriedades e por isso a utilização de variáveis.&lt;/p&gt;
&lt;p&gt;Cada instância terá todas as variáveis definidas em seu projeto, isto é, em sua classe. Logo, a alteração de uma variável na instância A não implica na alteração da variável de mesmo nome na instância B. Ambas instâncias forma criadas de um mesmo projeto, no entanto, são objetos distintos e a unica relação entre ambos é o projeto de sua construção.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;class Pessoa {&lt;/span&gt;
&lt;span class="x"&gt;    var $nome;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Toda variável contida em nossa classe é chamada de membro de classe, ou então, de propriedade ou atributo. Assim, temos que um objeto possui propriedades e estas são armazenadas nas variáveis que foram declaradas no escopo da classe da sua origem.&lt;/p&gt;
&lt;p&gt;Cada nova instância irá possuir as suas proprias propriedades e essas só poderão ser acessadas através da instância em que estão contidas.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="palavra-chave-var-e-public"&gt;
&lt;h2&gt;PALAVRA-CHAVE &lt;tt class="docutils literal"&gt;var&lt;/tt&gt; E &lt;tt class="docutils literal"&gt;public&lt;/tt&gt;&lt;/h2&gt;
&lt;p&gt;A declaração de variáveis numa classe ocorre de maneira um pouco diferente daquela que estudamos anteriormente, no início do nosso Curso de PHP. Aprendemos que basta definirmos um nome a atribuirmos a este um valor que já teremos uma variável. O que na declaração de variáveis dentro de classe é que a mesma deve ser precedida pelo seu nível de visibilidade. Inicialmente, estudaremos que as variáveis dentro de classe devem ser precedidas com a palavra-chave &lt;tt class="docutils literal"&gt;public&lt;/tt&gt;. No caso, estudaremos dessa forma pois estamos dizendo que todas as variáveis podem ser acessadas externamente, bastando somente a utilização de seu nome.&lt;/p&gt;
&lt;p&gt;Ainda é bastante comum encontrarmos código legado utilizando a palavra-chave para declaração de variáveis &lt;tt class="docutils literal"&gt;var&lt;/tt&gt;. Porém, essa é uma forma de declaração que entrou em desuso e o correto, atualmente, é utilizar uma das 3 opções:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;public&lt;/li&gt;
&lt;li&gt;private&lt;/li&gt;
&lt;li&gt;protected&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Estas 3 palavra-chaves, como pode ser deduzido, definem o nível de visibilidade que cada membro de classe terá. Nesse momento não estudaremos a visibilidade dos membros, então, utilizaremos em todos os exemplos a palavra-chave &lt;tt class="docutils literal"&gt;public&lt;/tt&gt;. Neste curso teremos, no mínimo, uma aulas para estudarmos a visibilidade dos membros de classe.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="exemplo-feito-em-aula"&gt;
&lt;h2&gt;EXEMPLO FEITO EM AULA&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;class Pessoa{&lt;/span&gt;
&lt;span class="x"&gt;    public $nome;&lt;/span&gt;
&lt;span class="x"&gt;    public $idade;&lt;/span&gt;

&lt;span class="x"&gt;    var $teste;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;No código acima que foi feito na vídeo-aula, estamos definindo 3 variáveis públicas. As 2 primeiras estão precedidas pela palavra-chave &lt;tt class="docutils literal"&gt;public&lt;/tt&gt; e a última pela palavra-chave &lt;tt class="docutils literal"&gt;var&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;Como já dito, a declaração de variáveis com o uso da palavra-chave &lt;tt class="docutils literal"&gt;var&lt;/tt&gt; não deve ser utilizada e só estamos demonstrando seu uso pois, ainda existe códigos definidos dessa maneira.&lt;/p&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Cláudio Rogério Carvalho Filho</dc:creator><pubDate>Wed, 01 Jun 2016 03:00:00 -0300</pubDate><guid isPermaLink="false">tag:excript.com,2016-06-01:php/membro-de-classe-php.html</guid><category>curso</category><category>php</category><category>programação orientada a objetos</category><category>poo</category><category>classe</category><category>objeto</category><category>instância</category><category>blog</category></item><item><title>Sobrescrita de Funções em PHP</title><link>http://excript.com/php/sobrescrita-funcao-php.html</link><description>
    &lt;div class="admonitionblock note data-line" style="margin-top: 1.50em"&gt;
        &lt;table style="margin: 0"&gt;
            &lt;tbody&gt;
                &lt;tr&gt;
                    &lt;td class="content" style="border-left: 0"&gt;
                        &lt;div class="paragraph data-line"&gt;
                            &lt;p&gt; Nessa aula estudaremos a sobrescrita de funções em classes derivadas. Essa é uma das formas de trabalharmos com polimorfismo atribuindo a funções de mesmo nome funcionalidades diferentes e também, é uma excelente maneira para especializarmos funcionalidades nas subclasses.&lt;/p&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/tbody&gt;
        &lt;/table&gt;
    &lt;/div&gt;
&lt;div class="section" id="exemplo-feito-em-aula"&gt;
&lt;h2&gt;EXEMPLO FEITO EM AULA&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;# SOBREESCRITA DE FUNÇÕES&lt;/span&gt;

&lt;span class="x"&gt;class Pessoa{&lt;/span&gt;
&lt;span class="x"&gt;    private $nome;&lt;/span&gt;
&lt;span class="x"&gt;    private $sobrenome;&lt;/span&gt;

&lt;span class="x"&gt;    public function getNome() : string&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        return $this-&amp;gt;nome;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    public function setNome(string $nome)&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;nome = $nome;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    public function getSobrenome() : string&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;    return $this-&amp;gt;sobrenome;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    public function setSobrenome(string $sobrenome)&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;sobrenome = $sobrenome;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;

&lt;span class="x"&gt;    public function getNomeCompleto() : string&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        return $this-&amp;gt;getNome() . &amp;quot; &amp;quot; . $this-&amp;gt;getSobrenome();&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;

&lt;span class="x"&gt;class PFisica extends Pessoa{&lt;/span&gt;

&lt;span class="x"&gt;//    public function getNomeCompleto() : string&lt;/span&gt;
&lt;span class="x"&gt;//    {&lt;/span&gt;
&lt;span class="x"&gt;//        return &amp;quot;PFisica: {$this-&amp;gt;getNome()} {$this-&amp;gt;getSobrenome()}&amp;quot;;&lt;/span&gt;
&lt;span class="x"&gt;//    }&lt;/span&gt;

&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Cláudio Rogério Carvalho Filho</dc:creator><pubDate>Sun, 21 Feb 2016 10:09:00 -0300</pubDate><guid isPermaLink="false">tag:excript.com,2016-02-21:php/sobrescrita-funcao-php.html</guid><category>curso</category><category>php</category><category>programação orientada a objetos</category><category>poo</category><category>oo</category><category>orientação a objetos</category><category>modificadores</category><category>modificador de acesso</category><category>classe</category><category>objeto</category><category>instância</category><category>herança</category><category>subclasse</category><category>superclasse</category><category>polimorfismo</category></item><item><title>Funções Modificadoras em PHP</title><link>http://excript.com/php/funcoes-modificadoras-php.html</link><description>
    &lt;div class="admonitionblock note data-line" style="margin-top: 1.50em"&gt;
        &lt;table style="margin: 0"&gt;
            &lt;tbody&gt;
                &lt;tr&gt;
                    &lt;td class="content" style="border-left: 0"&gt;
                        &lt;div class="paragraph data-line"&gt;
                            &lt;p&gt; Nesta aula estudaremos as funções manipuladoras, comumente chamadas de getters e setters. Também aprenderemos quando utiliza-las e quais são as características e beneficios na construção de classes que implementam essa metodologia.&lt;/p&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/tbody&gt;
        &lt;/table&gt;
    &lt;/div&gt;
&lt;div class="section" id="exemplo-feito-em-aula"&gt;
&lt;h2&gt;EXEMPLO FEITO EM AULA&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;# FUNÇÕES DE ACESSO&lt;/span&gt;

&lt;span class="x"&gt;class Pessoa{&lt;/span&gt;

&lt;span class="x"&gt;    private $nome;&lt;/span&gt;
&lt;span class="x"&gt;    private $sobrenome;&lt;/span&gt;

&lt;span class="x"&gt;    public function getNome() : string&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        return $this-&amp;gt;nome;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    public function setNome(string $nome)&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;nome = $nome;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    public function getSobrenome() : string&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        return $this-&amp;gt;sobrenome;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    public function setSobrenome(string $sobrenome)&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;sobrenome = $sobrenome;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;

&lt;span class="x"&gt;    public function getNomeCompleto() : string&lt;/span&gt;
&lt;span class="x"&gt;    {&lt;/span&gt;
&lt;span class="x"&gt;        return $this-&amp;gt;getNome() . &amp;quot; &amp;quot; . $this-&amp;gt;getSobrenome();&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;

&lt;span class="x"&gt;}&lt;/span&gt;

&lt;span class="x"&gt;$p1 = new Pessoa();&lt;/span&gt;
&lt;span class="x"&gt;$p1-&amp;gt;setNome(&amp;quot;eXcript&amp;quot;);&lt;/span&gt;
&lt;span class="x"&gt;$p1-&amp;gt;setSobrenome(&amp;quot;Brasil&amp;quot;);&lt;/span&gt;

&lt;span class="x"&gt;//echo $p1-&amp;gt;getNome() . &amp;quot;\n&amp;quot;;&lt;/span&gt;
&lt;span class="x"&gt;//echo $p1-&amp;gt;getSobrenome() . &amp;quot;\n&amp;quot;;&lt;/span&gt;

&lt;span class="x"&gt;echo $p1-&amp;gt;getNomeCompleto();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Cláudio Rogério Carvalho Filho</dc:creator><pubDate>Thu, 18 Feb 2016 21:52:00 -0200</pubDate><guid isPermaLink="false">tag:excript.com,2016-02-18:php/funcoes-modificadoras-php.html</guid><category>curso</category><category>php</category><category>programação orientada a objetos</category><category>poo</category><category>funções</category><category>funções modificadoras</category><category>get</category><category>set</category><category>getter</category><category>setter</category><category>classe</category><category>objeto</category><category>instância</category></item><item><title>Visibilidade das Funções em PHP</title><link>http://excript.com/php/visibilidade-funcao-php.html</link><description>
    &lt;div class="admonitionblock note data-line" style="margin-top: 1.50em"&gt;
        &lt;table style="margin: 0"&gt;
            &lt;tbody&gt;
                &lt;tr&gt;
                    &lt;td class="content" style="border-left: 0"&gt;
                        &lt;div class="paragraph data-line"&gt;
                            &lt;p&gt; Nesta aula estudaremos a visibilidade das funções definidas numa classe e as razões pelas quais devemos restringir o acesso a todos os membros que possuem uso interno a classe.&lt;/p&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/tbody&gt;
        &lt;/table&gt;
    &lt;/div&gt;
&lt;div class="section" id="exemplo-feito-em-aula"&gt;
&lt;h2&gt;EXEMPLO FEITO EM AULA&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;# VISIBILIDADE DAS FUNÇÕES&lt;/span&gt;

&lt;span class="x"&gt;class SuperClasse{&lt;/span&gt;

&lt;span class="x"&gt;    public $uuu;&lt;/span&gt;

&lt;span class="x"&gt;    public function funcPublica(){ echo &amp;quot;funcPublica\n&amp;quot;; }&lt;/span&gt;
&lt;span class="x"&gt;    protected function funcProtegida(){ echo &amp;quot;funcProtegida\n&amp;quot;; }&lt;/span&gt;
&lt;span class="x"&gt;    private function funcPrivada(){ echo &amp;quot;funcPrivada\n&amp;quot;; }&lt;/span&gt;

&lt;span class="x"&gt;    function super(){&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;funcPublica();&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;funcProtegida();&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;funcPrivada();&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;

&lt;span class="x"&gt;}&lt;/span&gt;

&lt;span class="x"&gt;$super = new SuperClasse();&lt;/span&gt;
&lt;span class="x"&gt;//$super-&amp;gt;super();&lt;/span&gt;
&lt;span class="x"&gt;$super-&amp;gt;funcPublica();&lt;/span&gt;
&lt;span class="x"&gt;//$super-&amp;gt;funcProtegida();&lt;/span&gt;
&lt;span class="x"&gt;//$super-&amp;gt;funcPrivada();&lt;/span&gt;

&lt;span class="x"&gt;class SubClasse extends SuperClasse{&lt;/span&gt;

&lt;span class="x"&gt;    function __construct(){&lt;/span&gt;

&lt;span class="x"&gt;        $this-&amp;gt;funcPublica();&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;funcProtegida();&lt;/span&gt;
&lt;span class="x"&gt;//        $this-&amp;gt;funcPrivada();&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;

&lt;span class="x"&gt;$sub = new SubClasse();&lt;/span&gt;
&lt;span class="x"&gt;$sub-&amp;gt;funcPublica();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Cláudio Rogério Carvalho Filho</dc:creator><pubDate>Sun, 14 Feb 2016 13:21:00 -0200</pubDate><guid isPermaLink="false">tag:excript.com,2016-02-14:php/visibilidade-funcao-php.html</guid><category>curso</category><category>php</category><category>programação orientada a objetos</category><category>poo</category><category>modificadores</category><category>modificador de acesso</category><category>visibilidade dos membros de classe</category><category>classe</category><category>objeto</category><category>instância</category></item><item><title>Modificadores de Acesso em PHP</title><link>http://excript.com/php/modificador-acesso-php.html</link><description>
    &lt;div class="admonitionblock note data-line" style="margin-top: 1.50em"&gt;
        &lt;table style="margin: 0"&gt;
            &lt;tbody&gt;
                &lt;tr&gt;
                    &lt;td class="content" style="border-left: 0"&gt;
                        &lt;div class="paragraph data-line"&gt;
                            &lt;p&gt; Nesta aula estudaremos a definição e uso dos modificadores de acesso aos membros de classe. Em seguida, estudaremos a aplicação dos modificadores ao realizarmos um exemplo prático demonstrando assim, os conceitos teóricos dos modificadores de acesso junto a um exemplo prático.&lt;/p&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/tbody&gt;
        &lt;/table&gt;
    &lt;/div&gt;
&lt;div class="section" id="introducao-aos-modificadores-de-acesso"&gt;
&lt;h2&gt;INTRODUÇÃO AOS MODIFICADORES DE ACESSO&lt;/h2&gt;
&lt;p&gt;Os membros de classe podem ter o seu nível de acesso alterado, ou seja, podemos definir que um membro de classe seja público, enquanto outro, tenha seu uso restrito a classe em que este foi declarado. Também é possível definir que um determinado membro esteja disponível somente dentro das classes derivadas.&lt;/p&gt;
&lt;p&gt;É comum nós falarmos que os modificadores de acesso alteram a visibilidade dos membros de classe, até porque, cada modificador define o nível de visibilidade e assim, temos membros visíveis em diferentes partes de um código.&lt;/p&gt;
&lt;p&gt;Cada membro de classe, implicitamente, possuirá um nível de acessibilidade que determinará onde o este poderá ser acessado.&lt;/p&gt;
&lt;p&gt;O conceito de restringir o acesso aos membros de classe está diretamente relacionado ao conceito de encapsulamento e abstração de dados, até porque, é dessa forma que restringiremos a visibilidade dos membros de uso interno da classe e também, será assim que disponibilizaremos uma interface de acesso.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="o-conceito-de-interface-publica"&gt;
&lt;h2&gt;O CONCEITO DE INTERFACE PÚBLICA&lt;/h2&gt;
&lt;p&gt;Uma interface pública, nada tem a ver com a parte gráfica de uma aplicação. Este conceito está relacionado com a orientação a objetos e significa o conjunto de funções e atributos que estão definidos como sendo de utilização público, ou seja, estes podem ser utilizados por qualquer instância ou então, pelas subclasses.&lt;/p&gt;
&lt;p&gt;Todo objeto irá possuir uma interface pública para que possamos interagir com o mesmo. Para a definição da interface pública, é recomendado o uso restritivo, isto é, sempre atribuir o maior grau de restrição possível a cada membro de classe. Isso faz com que tenhamos menos trabalho para testarmos cada estrutura, diminui a incompatibilidade entre futuras versões, garante coesão, abstração e encapsulamento da informação.&lt;/p&gt;
&lt;p&gt;A linguagem PHP, disponibiliza 3 modificadores de acesso:&lt;/p&gt;
&lt;p&gt;public (omissão) - o modificador que garante a visibilidade em qualquer lugar do nosso código
protected - restringe o acesso às classes derivadas
private. - restring o acesso a classe em que esta contido&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="os-conceitos-de-visibilidade-de-membros"&gt;
&lt;h2&gt;OS CONCEITOS DE VISIBILIDADE DE MEMBROS&lt;/h2&gt;
&lt;p&gt;A utilização dos modificadores de acesso é bastante simples, porém, há várias situações onde podemos nos confundir, e é por essa razão, que qualquer prova de orientação a objetos, tenha no mínimo uma questão sobre modificadores de acesso e por vezes, a questão é uma pegadinha.&lt;/p&gt;
&lt;p&gt;A maneira mais fácil, e na minha concepção, a mais lógica, é pensar da seguinte maneira:&lt;/p&gt;
&lt;p&gt;O que é público é de todos, então, uma membro público poderá ser acessado de qualquer lugar do nosso código, seja através de uma instância de classe, ou então, dentro de uma classe derivada.&lt;/p&gt;
&lt;p&gt;O que é privado, por outro lado, é de uso exclusivo e por isso, ninguém deve ter acesso. Por isso, temos que membros privados só poderão ser acessados dentro da classe onde estes foram declarados.&lt;/p&gt;
&lt;p&gt;Por fim temos o nível de acesso protegido. O que é protegido pode ser acessado, porém, com algumas ressalvas e devemos seguir algumas regras. Então, um membro protegido pode ser acessado, mas com uma condição: dentro das classes derivadas.&lt;/p&gt;
&lt;p&gt;Então, quando um programador define um membro como protegido, o que ele está dizendo, é que as subclasses, isto é, todas as classes herdeiras, podem acessar o membro diretamente. Porém, as instâncias terão o acesso restringido. Dai vem o nome protegido, ou seja, somente quem pode acessar é o pai e seus filhos, no caso, o membro protegido está restrito a família em que este foi definido.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="exemplo-feito-em-aula"&gt;
&lt;h2&gt;EXEMPLO FEITO EM AULA&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;# MODIFICADORES DE ACESSO I - public e private&lt;/span&gt;

&lt;span class="x"&gt;class SuperClasse{&lt;/span&gt;
&lt;span class="x"&gt;    public $publico = 0;&lt;/span&gt;
&lt;span class="x"&gt;    private $privada = 0;&lt;/span&gt;
&lt;span class="x"&gt;    protected $protegido = 0;&lt;/span&gt;
&lt;span class="x"&gt;    public function super(){&lt;/span&gt;
&lt;span class="x"&gt;        echo $this-&amp;gt;publico;&lt;/span&gt;
&lt;span class="x"&gt;        echo $this-&amp;gt;privada;&lt;/span&gt;
&lt;span class="x"&gt;        echo $this-&amp;gt;protegido;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;

&lt;span class="x"&gt;class SubClasse extends SuperClasse{&lt;/span&gt;
&lt;span class="x"&gt;    public $publico;&lt;/span&gt;
&lt;span class="x"&gt;    private $privada;&lt;/span&gt;
&lt;span class="x"&gt;    protected $protegido;&lt;/span&gt;
&lt;span class="x"&gt;    public function sub(int $x){&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;publico = $x;&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;privada = $x;&lt;/span&gt;
&lt;span class="x"&gt;        $this-&amp;gt;protegido = $x;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;

&lt;span class="x"&gt;$sub = new SubClasse();&lt;/span&gt;
&lt;span class="x"&gt;$sub-&amp;gt;sub(1);&lt;/span&gt;
&lt;span class="x"&gt;$sub-&amp;gt;super();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Cláudio Rogério Carvalho Filho</dc:creator><pubDate>Sat, 13 Feb 2016 11:13:00 -0200</pubDate><guid isPermaLink="false">tag:excript.com,2016-02-13:php/modificador-acesso-php.html</guid><category>curso</category><category>php</category><category>programação orientada a objetos</category><category>poo</category><category>modificadores</category><category>modificador de acesso</category><category>classe</category><category>objeto</category><category>instância</category></item><item><title>Encapsulamento em PHP (parte II)</title><link>http://excript.com/php/encapsulamento-php-parte2.html</link><description>
    &lt;div class="admonitionblock note data-line" style="margin-top: 1.50em"&gt;
        &lt;table style="margin: 0"&gt;
            &lt;tbody&gt;
                &lt;tr&gt;
                    &lt;td class="content" style="border-left: 0"&gt;
                        &lt;div class="paragraph data-line"&gt;
                            &lt;p&gt; Nesta aula daremos continuidade ao estudo dos conceito de encapsulamento, bem como as razões para utilização desse conceitos e os beneficios que podemos obter ao empregar essa metodologia de desenvolvimento.&lt;/p&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/tbody&gt;
        &lt;/table&gt;
    &lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Cláudio Rogério Carvalho Filho</dc:creator><pubDate>Sat, 06 Feb 2016 18:30:00 -0200</pubDate><guid isPermaLink="false">tag:excript.com,2016-02-06:php/encapsulamento-php-parte2.html</guid><category>curso</category><category>php</category><category>programação orientada a objetos</category><category>poo</category><category>encapsulamento</category><category>classe</category><category>objeto</category><category>instância</category></item><item><title>Encapsulamento em PHP</title><link>http://excript.com/php/encapsulamento-php.html</link><description>
    &lt;div class="admonitionblock note data-line" style="margin-top: 1.50em"&gt;
        &lt;table style="margin: 0"&gt;
            &lt;tbody&gt;
                &lt;tr&gt;
                    &lt;td class="content" style="border-left: 0"&gt;
                        &lt;div class="paragraph data-line"&gt;
                            &lt;p&gt; Nesta aula iniciaremos o estudo sobre o encapsulamento. Inicialmente, estudaremos o conceito prático encapsulamento ao analisarmos uma situação prática da necessidade da utilização. Em seguida, estudaremos os conceitos teóricos do encapsulamento segundo os conceitos da orientação a objetos.&lt;/p&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/tbody&gt;
        &lt;/table&gt;
    &lt;/div&gt;
&lt;div class="section" id="introducao"&gt;
&lt;h2&gt;INTRODUÇÃO&lt;/h2&gt;
&lt;p&gt;Uma classe é uma estrutura que contém um conjunto de dados, um conjunto de operações e tem implementado as funcionalidade necessárias para a correta manipulação das informações.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="encapsulamento"&gt;
&lt;h2&gt;ENCAPSULAMENTO&lt;/h2&gt;
&lt;p&gt;Todo objeto é, por definição, uma estrutura de dados especializada, também chamado de tipo abstraido de dados &lt;tt class="docutils literal"&gt;TAD&lt;/tt&gt;. As &lt;tt class="docutils literal"&gt;estruturas de dados&lt;/tt&gt;, normalmente, irão possuir membros de classes que armazenam valores - as variáveis; e membros de classe que desempenham alguma ação - as funções.&lt;/p&gt;
&lt;p&gt;Os membros de classe que são utilizados internamente, devem estar inacessíveis externamente. É interessante observar que isso não é meramente uma definição, mas sim, um conceito utilizado amplamente, inclusive pela própria natureza.&lt;/p&gt;
&lt;p&gt;Há várias formas para entendermos o encapsulamento, porém, talvez a mais importante seja a capacidade de definirmos um novo tipo de informação e fazer com que instâncias desse novo tipo sejam capazes de manter a integridade de suas informações.&lt;/p&gt;
&lt;p&gt;A única maneira para mantermos a integridade é verificando os dados que são enviados pelos membros de classe e estabelecendo através destes as regras para a correta atribuição de informações.&lt;/p&gt;
&lt;p&gt;Encapsular implica na modificação da visibilidade de membros de classe e portanto, foram definidos algumas palavras-chaves para explicitamente definirmos o escopo de cada membro.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="abstracao"&gt;
&lt;h2&gt;ABSTRAÇÃO&lt;/h2&gt;
&lt;p&gt;A abstração é uma das característica de um bom encapsulamento. Entretanto, podemos escrever um código que abstrai um processo sem encapsular o mesmo. Por exemplo, um função que resolve uma somatória abstrai o cálculo através do uso de funções, porém, só com o uso de funções, não haverá encapsulamento de informação nem funcionalidade.&lt;/p&gt;
&lt;p&gt;Ao ocultarmos informações, estamos protegemos nossa estrutura da má utilização por parte do usuário e por conseguinte, acabamos protegendo o usuário de uma eventual má implementação.&lt;/p&gt;
&lt;p&gt;Assim, a abstração também é a simplificação de processos complexos. Um programa é uma abstração de algoritmos em partes independentes e que são projetados para se conectarem a outras abstrações.&lt;/p&gt;
&lt;p&gt;Uma função abstrai um processo tornando-o acessível através de um nome e seus parâmetros; uma classe abstraí um tipo de dado e suas funções de tratamento e manipulação.&lt;/p&gt;
&lt;p&gt;Quando encapsulamos um processo estaremos abstraíndo a implementação e também, os possíveis dados que são utilizados. O objetivo com a encapsulação e a abstração, é ocultar os processos e dados internos, mas disponibilizar uma interface simples para a utilização desse tipo abstrato de dados. Até porque, não existe encapsulação e abstração se não houver uma forma para o acesso das informações e funcionalidades encapsuladas. Se não houver uma interface de comunicação, nós temos um módulo independente, que é executado isoladamente e não há razão para mantermos esse código dentro de qualquer outro. Se não houver uma maneira de acesso, não haverá, por definição, utilidade e uso do código.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="exemplo-feito-em-aula"&gt;
&lt;h2&gt;EXEMPLO FEITO EM AULA&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;# ENCAPSULAMENTO&lt;/span&gt;

&lt;span class="x"&gt;class Pessoa{&lt;/span&gt;

&lt;span class="x"&gt;    private $nome;&lt;/span&gt;

&lt;span class="x"&gt;    function setNome($nome){&lt;/span&gt;
&lt;span class="x"&gt;        $this -&amp;gt; nome = $nome;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    function getNome(){&lt;/span&gt;
&lt;span class="x"&gt;        return $this -&amp;gt; nome;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;

&lt;span class="x"&gt;}&lt;/span&gt;

&lt;span class="x"&gt;$p1 = new Pessoa();&lt;/span&gt;
&lt;span class="x"&gt;//$p1 -&amp;gt; setNome(&amp;quot;eXcript&amp;quot;);&lt;/span&gt;
&lt;span class="x"&gt;$p1 -&amp;gt; nome = &amp;quot;&amp;quot;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Cláudio Rogério Carvalho Filho</dc:creator><pubDate>Fri, 05 Feb 2016 12:37:00 -0200</pubDate><guid isPermaLink="false">tag:excript.com,2016-02-05:php/encapsulamento-php.html</guid><category>curso</category><category>php</category><category>programação orientada a objetos</category><category>poo</category><category>encapsulamento</category><category>classe</category><category>objeto</category><category>instância</category></item><item><title>Destrutores em PHP</title><link>http://excript.com/php/destrutores-php.html</link><description>
    &lt;div class="admonitionblock note data-line" style="margin-top: 1.50em"&gt;
        &lt;table style="margin: 0"&gt;
            &lt;tbody&gt;
                &lt;tr&gt;
                    &lt;td class="content" style="border-left: 0"&gt;
                        &lt;div class="paragraph data-line"&gt;
                            &lt;p&gt; Nesta aula estudaremos a implementação de funções destrutoras que são invocadas no momento que precede a remoção de uma instância da memória.&lt;/p&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/tbody&gt;
        &lt;/table&gt;
    &lt;/div&gt;
&lt;div class="section" id="destrutores"&gt;
&lt;h2&gt;DESTRUTORES&lt;/h2&gt;
&lt;p&gt;A linguagem PHP tem definido uma função que é invocada todas as vezes em que uma instância estiver sendo criada e também, possui uma função que será invocada, todas as vezes em que um instância estiver sendo destruida.&lt;/p&gt;
&lt;p&gt;A função que destruira a instância e removerás qualquer valor associado possui o nome de &lt;tt class="docutils literal"&gt;__destruct()&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;Basicamente, podemos dizer que o destrutor é invocado quando nenhuma variável estiver referenciando este, ou então, quando a função &lt;tt class="docutils literal"&gt;unset()&lt;/tt&gt; for invocada passando como parâmetro a instância.&lt;/p&gt;
&lt;p&gt;A função destrutor de uma classe sempre será invocado antes da classe ser removida da memória, portanto, somos capazes de executar qualquer código antes que a instância seja destruida.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="funcao-que-destroi-a-instancia-passada-como-parametro"&gt;
&lt;h2&gt;FUNÇÃO QUE DESTROI A INSTÂNCIA PASSADA COMO PARÂMETRO&lt;/h2&gt;
&lt;p&gt;Já trabalhamos com a função &lt;tt class="docutils literal"&gt;unset()&lt;/tt&gt; quando estavamos estudando Arrays, e fizemos uso da mesma para removermos um elemento da estrutura e também, remove-lo da memória.&lt;/p&gt;
&lt;p&gt;Durante a implementação de destrutores iremos fazer uso extensivo da função unset(), haja vista que essa é a maneira mais simples e segura que um objeto realmente será destruido, ou melhor, será enviado para o Garbage Collector.&lt;/p&gt;
&lt;p&gt;A melhor maneira para testarmos se a função de destruição de um objeto está funcionando corretamente.&lt;/p&gt;
&lt;p&gt;Vale ressaltar que a função &lt;tt class="docutils literal"&gt;unset()&lt;/tt&gt; ocasiona da destruição e remoção dos valores da memória de maneira irreversível, após invocarmos passando como parâmetro uma instância, não existira função para voltar atrás.&lt;/p&gt;
&lt;blockquote&gt;
A função &lt;tt class="docutils literal"&gt;unset()&lt;/tt&gt; desvincula uma instância de toda e qualquer estrutura ou então, outra instância.&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="garbage-collector"&gt;
&lt;h2&gt;GARBAGE COLLECTOR&lt;/h2&gt;
&lt;p&gt;O coletor de lixo, ou então, o &lt;tt class="docutils literal"&gt;Garbage Collector&lt;/tt&gt; é uma entidade especializada em remover os dados da memória que não estão mais sendo utilizados.&lt;/p&gt;
&lt;p&gt;A utilização de um coletor de lixo simplifica o trabalho do programador e evitar a grande maioria dos problemas de software, até porque, fazer acesso a uma região de memória que foi desalocada pode ocasionar problemas bizarros e que são muito dificeis de serem depurados.&lt;/p&gt;
&lt;p&gt;Então, pense no coletor de lixo como o agente responsavel em liberar toda e qualquer informação que não esteja mais em uso e principalmente, fazer todo esse trabalho de gerenciamento e averiguação de quais instâncias não estão mais em uso num bloco de instrução.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;unset($r);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="exemplo-feito-em-aula"&gt;
&lt;h2&gt;EXEMPLO FEITO EM AULA&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;#DESTRUTORES&lt;/span&gt;

&lt;span class="x"&gt;class Pessoa{&lt;/span&gt;

&lt;span class="x"&gt;    function __construct(){&lt;/span&gt;
&lt;span class="x"&gt;        echo &amp;quot;Função construtora invocada.&amp;quot;;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;

&lt;span class="x"&gt;    function __destruct(){&lt;/span&gt;
&lt;span class="x"&gt;        echo &amp;quot;Função destrutora invocada.&amp;quot;;&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;

&lt;span class="x"&gt;}&lt;/span&gt;

&lt;span class="x"&gt;$p1 = new Pessoa;&lt;/span&gt;
&lt;span class="x"&gt;unset($p1);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Cláudio Rogério Carvalho Filho</dc:creator><pubDate>Tue, 19 Jan 2016 19:10:00 -0200</pubDate><guid isPermaLink="false">tag:excript.com,2016-01-19:php/destrutores-php.html</guid><category>curso</category><category>php</category><category>programação orientada a objetos</category><category>poo</category><category>destrutor</category><category>construtor</category><category>classe</category><category>objeto</category><category>instância</category></item><item><title>Construtores Personalizados em PHP</title><link>http://excript.com/php/construtor-personalizado-php.html</link><description>
    &lt;div class="admonitionblock note data-line" style="margin-top: 1.50em"&gt;
        &lt;table style="margin: 0"&gt;
            &lt;tbody&gt;
                &lt;tr&gt;
                    &lt;td class="content" style="border-left: 0"&gt;
                        &lt;div class="paragraph data-line"&gt;
                            &lt;p&gt; Nesta aula daremos continuidade sobre a utilização de funções construtoras e os seus beneficios na construção e implementação de classes.&lt;/p&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/tbody&gt;
        &lt;/table&gt;
    &lt;/div&gt;
&lt;div class="section" id="construtores-personalizados"&gt;
&lt;h2&gt;CONSTRUTORES PERSONALIZADOS&lt;/h2&gt;
&lt;p&gt;A definição de construtores é praticamente igual a definição de funções, então, seguindo a definição de funções, é permitido a declaração de parâmetros no cabeçalho do construtor. Está é a melhor forma para definirmos os principais valores de um objeto ainda em sua inicialização, prática essa muito utilizada quando estamos trabalhando com banco de dados.&lt;/p&gt;
&lt;p&gt;A definição de parâmetros no construtor, implica na obrigatoriedade de enviar esses valores, todas as vezes em que uma nova instância estiver sendo definida.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="visibilidade-dos-construtores"&gt;
&lt;h2&gt;VISIBILIDADE DOS CONSTRUTORES&lt;/h2&gt;
&lt;p&gt;Se a visibilidade de um construtor não for definida, assume-se que o mesmo é público. Temos que o funcionamento da visibilidade dos construtores é igual a visibilidade dos métodos.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;$p1 = new Pessoa(&amp;quot;João&amp;quot;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A utilização de construtores faz com que nossos objetos se tornem mais lógicos e acessíveis.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="exemplo-feito-em-aula"&gt;
&lt;h2&gt;EXEMPLO FEITO EM AULA&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;#CONSTRUTORES PERSONALIZADOS&lt;/span&gt;

&lt;span class="x"&gt;class A{&lt;/span&gt;

&lt;span class="x"&gt;}&lt;/span&gt;

&lt;span class="x"&gt;class Pessoa{&lt;/span&gt;

&lt;span class="x"&gt;    public $a;&lt;/span&gt;

&lt;span class="x"&gt;    public $nome;&lt;/span&gt;
&lt;span class="x"&gt;    public $idade = 0;&lt;/span&gt;

&lt;span class="x"&gt;    function __construct($nome, $idade){&lt;/span&gt;

&lt;span class="x"&gt;        $this -&amp;gt; a = new A();&lt;/span&gt;

&lt;span class="x"&gt;        $this -&amp;gt; nome = $nome;&lt;/span&gt;
&lt;span class="x"&gt;        $this -&amp;gt; idade = $idade;&lt;/span&gt;

&lt;span class="x"&gt;    }&lt;/span&gt;

&lt;span class="x"&gt;}&lt;/span&gt;

&lt;span class="x"&gt;$p1 = new Pessoa(&amp;quot;eXcript&amp;quot;, 2);&lt;/span&gt;
&lt;span class="x"&gt;var_dump($p1);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Cláudio Rogério Carvalho Filho</dc:creator><pubDate>Tue, 19 Jan 2016 12:07:00 -0200</pubDate><guid isPermaLink="false">tag:excript.com,2016-01-19:php/construtor-personalizado-php.html</guid><category>curso</category><category>php</category><category>programação orientada a objetos</category><category>poo</category><category>construtor</category><category>classe</category><category>objeto</category><category>instância</category></item><item><title>Construtores em PHP</title><link>http://excript.com/php/construtor-php.html</link><description>
    &lt;div class="admonitionblock note data-line" style="margin-top: 1.50em"&gt;
        &lt;table style="margin: 0"&gt;
            &lt;tbody&gt;
                &lt;tr&gt;
                    &lt;td class="content" style="border-left: 0"&gt;
                        &lt;div class="paragraph data-line"&gt;
                            &lt;p&gt; Nessa aula estudaremos os construtores de classe, ou seja, funções que são invocadas no momento em que uma nova instância de classe está sendo criada. Também estudaremos a inicialização de classe, ou seja, veremos quais os passos ocorridos a cada nova instância criada.&lt;/p&gt;
                        &lt;/div&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/tbody&gt;
        &lt;/table&gt;
    &lt;/div&gt;
&lt;div class="section" id="construtores"&gt;
&lt;h2&gt;CONSTRUTORES&lt;/h2&gt;
&lt;p&gt;Construtor é um bloco de instrução, semelhante a uma função, definido implicita ou explicitamente por todas as classes, que é invocado automaticamente pela Máquina Virtual, todas as vezes que um objeto está sendo criado. Construtores são definidos como sendo funções, porém, não o são! Isso porque, funções retornam valores e o único valor que um construtor poderia retornar, seria a instância que está sendo no mesmo instante definida.&lt;/p&gt;
&lt;p&gt;Porém, num primeiro momento, vamos pensar num construtor como sendo um método, até porque, o mesmo possui um nome, um corpo e pode receber parâmetros. Porém, um construtor não pode ser invocado quando desejarmos, ou melhor, o construtor é um bloco de código que será invocado &lt;strong&gt;só e somente só na criação de novas instâncias&lt;/strong&gt;.&lt;/p&gt;
&lt;!-- Uma classe pode conter quantos construtores forem necessário, desde que a assinatura destes sejam diferentes. --&gt;
&lt;/div&gt;
&lt;div class="section" id="definicao"&gt;
&lt;h2&gt;DEFINIÇÃO&lt;/h2&gt;
&lt;p&gt;O nome do construtor de todas as classes sempre será &lt;code&gt;__construct()&lt;/code&gt;. Essa é uma convenção da linguagem e não há como trabalhar de maneira diferente. Dessa forma, é fácil identificarmos o construtor da classe, até porque, todas utilizarão o padrão.&lt;/p&gt;
&lt;p&gt;A seguir, temos algumas regras que se aplicão aos contrutores.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;O construtor que será invocado na criação de novos objetos tem o nome de:  &lt;tt class="docutils literal"&gt;__construct&lt;/tt&gt;. Os dois &lt;tt class="docutils literal"&gt;underlines&lt;/tt&gt; a frente do nome é obrigatório.&lt;/li&gt;
&lt;li&gt;Construtores são geralmente utilizados para trabalharmos com valores não literais, isto é, para trabalharmos com objetos. A razão é bastante simples: todo objeto precisa ser criado e isso é feito dentro de algum bloco de instrução.&lt;/li&gt;
&lt;li&gt;O PHP primeiro cria uma nova instância de um objeto para somente então invocar o seu construtor. Do contrário, não seria possível, por exemplo, acessar os membros da classe e nem fazer uso da pseudo-variável &lt;tt class="docutils literal"&gt;$this&lt;/tt&gt;. Assim, primeiro cria-se uma nova instância e, somente depois é que o construtor será invocado.&lt;/li&gt;
&lt;li&gt;As variáveis de uma classe são inicializadas antes do construtor ser invocado, assim, se alterarmos o valor de um atributo dentro do bloco do construtor, este passará a ser o valor assumido por todas as instâncias.&lt;/li&gt;
&lt;li&gt;O PHP tem definido que, construtores que não recebem parâmetros poderão ter suas instâncias criadas sem a utilização do par de parêntesis.&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- Isto pode ser utilizado para tornar os valores iniciais das propriedades dependentes dos parâmetros passados quando o objecto é criado. --&gt;
&lt;/div&gt;
&lt;div class="section" id="exemplo-feito-em-aula"&gt;
&lt;h2&gt;EXEMPLO FEITO EM AULA&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;#CONSTRUTORES&lt;/span&gt;

&lt;span class="x"&gt;class Pessoa{&lt;/span&gt;

&lt;span class="x"&gt;    public $idade = 0;&lt;/span&gt;
&lt;span class="x"&gt;    public $nome;&lt;/span&gt;

&lt;span class="x"&gt;    function aaa(){&lt;/span&gt;

&lt;span class="x"&gt;    }&lt;/span&gt;
&lt;span class="x"&gt;    function bbb(){&lt;/span&gt;

&lt;span class="x"&gt;    }&lt;/span&gt;

&lt;span class="x"&gt;    function __construct(){&lt;/span&gt;
&lt;span class="x"&gt;        echo &amp;quot;teste\n&amp;quot;;&lt;/span&gt;
&lt;span class="x"&gt;        var_dump($this);&lt;/span&gt;
&lt;span class="x"&gt;    }&lt;/span&gt;

&lt;span class="x"&gt;}&lt;/span&gt;

&lt;span class="x"&gt;$p1 = new Pessoa();&lt;/span&gt;
&lt;span class="x"&gt;$p2 = new Pessoa();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Cláudio Rogério Carvalho Filho</dc:creator><pubDate>Mon, 18 Jan 2016 12:17:00 -0200</pubDate><guid isPermaLink="false">tag:excript.com,2016-01-18:php/construtor-php.html</guid><category>curso</category><category>php</category><category>programação orientada a objetos</category><category>poo</category><category>construtor</category><category>classe</category><category>objeto</category><category>instância</category><category>blog</category></item></channel></rss>